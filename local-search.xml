<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis设计与实现（3-字典）</title>
    <link href="/RoyalLiang.github.io/2020/08/12/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%883-%E5%AD%97%E5%85%B8%EF%BC%89/"/>
    <url>/RoyalLiang.github.io/2020/08/12/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%883-%E5%AD%97%E5%85%B8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>字典：用于保存键值对（key-value pair）的抽象数据结构。</p><p>字典是Redis的数据库的底层实现，也是哈希的底层实现之一，但由于C语言没有字典这一数据结构，所以Redis自己构建了该数据结构。</p><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h4 id="Redis的哈希表实现"><a href="#Redis的哈希表实现" class="headerlink" title="Redis的哈希表实现"></a>Redis的哈希表实现</h4><p>Redis字典所使用的哈希表由dict.h/dictht结构定义：</p><pre><code class="hljs plain">typedef struct dictht&#123;    &#x2F;&#x2F;哈希表数组    dictEntry **table;    &#x2F;&#x2F;哈希表大小    unsigned long size;    &#x2F;&#x2F;哈希表大小掩码。用于计算索引值，总是等于size - 1    unsigned long sizemask;    &#x2F;&#x2F;哈希表已有节点的数量    unsigned long used;&#125; dictht;</code></pre><blockquote><p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。</p></blockquote><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p><pre><code class="hljs plain">typedef struct dictEntry&#123;    &#x2F;&#x2F;键    void *key;    &#x2F;&#x2F;值    union &#123;        void *val;        uint64_tu64;        int64_ts64;    &#125; v;    &#x2F;&#x2F;指向下一个哈希表节点，形成链表    struct dictEntry *next;&#125; dictEntry;</code></pre><blockquote><p>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。</p><p>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。</p></blockquote><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典由dict.h/dict结构表示：</p><pre><code class="hljs plain">typedef struct dict&#123;    &#x2F;&#x2F;类型特定函数    dictType *type;    &#x2F;&#x2F;私有数据    void *privdata;    &#x2F;&#x2F;哈希表    dictht ht[2];    &#x2F;&#x2F;rehash索引，当rehash不在进行时，值 &#x3D;&#x3D; -1    int trehashidx;&#125; dict;</code></pre><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p><blockquote><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p><p>privdata属性保存了需要传给那些类型特定函数的可选参数。</p><p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</p><p>rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</p></blockquote><p>dictType结构体定义如下：</p><pre><code class="hljs plain">typedef struct dictType&#123;    &#x2F;&#x2F;计算哈希值的函数    unsigned int (*hashFunction)(const void *key);    &#x2F;&#x2F;复制键的函数    void *(*keyDup)(void *privdata, const void *key);    &#x2F;&#x2F;复制值的函数    void *(*valDup)(void *privdata, const void *key);    &#x2F;&#x2F;对比键的函数    int (*keyCompare)(void *privdata, const void *key1, const void *key2);    &#x2F;&#x2F;销毁键的函数    void (*keyDestructor)(void *privdata, void *key);    &#x2F;&#x2F;销毁值的函数    void (*valDestructor)(void *privdata, void *obj);&#125; dictType;</code></pre><p>（未完，待补充～）</p><p>下图是一个未进行rehash的普通字典案例：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/330602/1590999682359-e98ca156-021d-425e-8712-fb42a39b9658.png" srcset="/RoyalLiang.github.io/img/loading.gif" alt="截屏2020-06-01 下午4.20.32.png"></p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p><strong>当字典被用作数据库的底层实现，或者哈希键的底层实现时，**</strong>Redis使用MurmurHash2算法来计算键的哈希值。**</p><blockquote><p>MurmurHash算法最初由Austin Appleby于2008年发明，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。</p></blockquote><p>对于新添加到字典的键值对来说，程序首先需要根据键进行哈希计算，计算出其哈希值与索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上。</p><p>Redis计算哈希值与索引值的方法如下：</p><pre><code class="hljs plain">&#x2F;&#x2F;使用字典设置的哈希函数，计算键的哈希值hash &#x3D; dict -&gt; type -&gt; hashFunction(key);&#x2F;&#x2F;使用哈希表的sizemask属性和哈希值，计算索引，根据不同情况，ht[x]可以是ht[0]或ht[1]idx &#x3D; hash &amp; dict[x].sizemask</code></pre><p>eg：将 k0 与 v0 添加到字典</p><pre><code class="hljs plain">&#x2F;&#x2F;1. 计算哈希hash &#x3D; dict -&gt; type -&gt; hashFunction(k0);&#x2F;&#x2F;2. 计算索引，设k0&#x3D;8，dict -&gt; table 的 size为4idx &#x3D; 8 &amp; ht[0].sizemask &#x3D; 8 &amp; 3 &#x3D; 0;&#x2F;&#x2F;放置新的键值对&#x2F;&#x2F;根据idx的值，新的键值对将会放在table数组的第一位</code></pre><p>示例图如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/330602/1591001098299-b4b32701-7fb7-4fca-89fc-a20b385f5836.png" srcset="/RoyalLiang.github.io/img/loading.gif" alt="截屏2020-06-01 下午4.44.06.png"></p><h3 id="键冲突"><a href="#键冲突" class="headerlink" title="键冲突"></a>键冲突</h3><p>当哈希表数组同一索引上的键等于或超过 2 以上时，就会产生键冲突，而<strong>Redis的哈希表通过链地址法来解决冲突。</strong></p><p>链地址法：</p><blockquote><p>每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，以此解决键冲突的问题。</p><p>由于 dictEntry 节点组成的链表没有指向链表表尾的指针。为了速度考虑，程序总是将新节点添加到链表的表头位置。</p></blockquote><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>随着操作的不断执行，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>Redis对字典的哈希表执行rehash的步骤如下：</p><ol><li>为字典ht[1]哈希表分配空间，空间大小取决于执行的操作，以及ht[0]当前的键值对数量（used属性的值）。</li></ol><ul><li>扩充操作：ht[1].size 等于第一个大于等于 ht[0].used * 2 的 2n</li><li>缩减操作：ht[1].size 等于第一个大于等于 ht[0].used 的 2n</li></ul><ol><li>将保存在ht[0]中的所有键值对rehash到ht[1]上，reshash指的是重新计算键的哈希值与索引值。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li></ol><h3 id="扩容-收缩条件"><a href="#扩容-收缩条件" class="headerlink" title="扩容/收缩条件"></a>扩容/收缩条件</h3><p>当出现一下任意情况时，哈希表会自动扩容</p><blockquote></blockquote><ul><li>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ul><p><code>负载因子</code>的计算如下：</p><pre><code class="hljs plain"># 负载因子 &#x3D; 哈希表已使用节点数 &#x2F; 哈希表大小load_factory &#x3D; ht[0].used &#x2F; ht[0].size</code></pre><p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p><p>备注：</p><blockquote><p>当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p></blockquote><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</p><p>哈希表渐进式rehash的详细步骤如下：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值加 1。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</li></ol><blockquote><p>在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。</p><p>在渐进式rehash执行期间，新添加到字典的键值对一律会保存到ht[1]里面，ht[0]则不再进行任何添加操作，保证ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。</p></blockquote><h3 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h3><table><thead><tr><th>函数</th><th>功能</th><th>时间复杂度</th></tr></thead><tbody><tr><td>dictCreate</td><td>创建一个空字典</td><td>O(1)</td></tr><tr><td>dictAdd</td><td>添加指定的kv到字典中</td><td>O(1)</td></tr><tr><td>dictReplace</td><td>添加指定的kv到字典中，如果已经存在，则替换</td><td>O(1)</td></tr><tr><td>dictFetchValue</td><td>返回给定键的值</td><td>O(1)</td></tr><tr><td>dictGetRandomKey</td><td>返回随机的kv</td><td>O(1)</td></tr><tr><td>dictDelete</td><td>删除给定键对应的键值对</td><td>O(1)</td></tr><tr><td>dictRelease</td><td>释放给定字典</td><td>O(n)</td></tr></tbody></table><h3 id="字典总结"><a href="#字典总结" class="headerlink" title="字典总结"></a>字典总结</h3><blockquote><p>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</p><p>Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</p><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</p><p>哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</p><p>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis设计与实现（2-链表）</title>
    <link href="/RoyalLiang.github.io/2020/06/16/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%882-%E9%93%BE%E8%A1%A8%EF%BC%89/"/>
    <url>/RoyalLiang.github.io/2020/06/16/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%882-%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>链表是Redis底层用非常广泛的数据结构。使用范围包含但不限于：列表键，发布与订阅、慢查询、监视器、客户端状态信息等</p><h3 id="链表节点实现"><a href="#链表节点实现" class="headerlink" title="链表节点实现"></a>链表节点实现</h3><p>每个链表节点使用一个adlist.h/listNode结构来表示：</p><pre><code class="hljs plain">typedef struct listNode&#123;    &#x2F;&#x2F;前置节点    struct listNode * prev;    &#x2F;&#x2F;后置节点    struct listNode * next;    &#x2F;&#x2F;节点值    void * value;&#125;listNode;</code></pre><p>使用多个listNode结构就可以组成链表，但使用adlist.h/list来持有链表的话，操作起来会更方便：</p><pre><code class="hljs plain">typedef struct list&#123;    &#x2F;&#x2F;头节点    listNode * head;    &#x2F;&#x2F;尾节点    listNode * tail;    &#x2F;&#x2F;链表节点数量    unsigned long len;    &#x2F;&#x2F;节点值复制函数    void *(*dup)(void *ptr);    &#x2F;&#x2F;节点值释放函数    void *(*free)(void *ptr);    &#x2F;&#x2F;节点值比较函数    void *(*match)(void *ptr, void *key);&#125;list;</code></pre><blockquote><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p></blockquote><ol><li>dup函数用于复制链表节点所保存的值；</li><li>free函数用于释放链表节点所保存的值；</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li></ol><p>Redis链表特征：</p><ol><li>双端，每个节点都带有prev节点和next节点。</li><li>无环，表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针。</li><li>带链表长度计数器，程序使用list结构的len属性来对list持有的链表节点进行计数。</li><li>多态，链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ol><h3 id="链表-API"><a href="#链表-API" class="headerlink" title="链表 API"></a>链表 API</h3><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>listSetDupMethod</td><td>将给定的函数设置成链表节点值复制函数</td><td>O(1)，通过链表的dup属性直接获得</td></tr><tr><td>listGetDupMethod</td><td>返回链表当前正在使用的节点值复制函数</td><td>O(1)</td></tr><tr><td>listSetFreeMethod</td><td>将给定的函数设置成链表节点值释放函数</td><td>O(1)</td></tr><tr><td>listGetFree</td><td>返回链表当前节点值释放函数</td><td>O(1)</td></tr><tr><td>listSetMatchMethod</td><td>将给定的函数设置成链表节点值对比函数</td><td>O(1)</td></tr><tr><td>listGetMatchMethod</td><td>返回链表当前节点值对比函数</td><td>O(1)</td></tr><tr><td>listLength</td><td>返回链表长度</td><td>O(1)</td></tr><tr><td>listFirst</td><td>返回链表头节点</td><td>O(1)</td></tr><tr><td>listLast</td><td>返回链表尾节点</td><td>O(1)</td></tr><tr><td>listPrevNode</td><td>返回给定节点的前置节点</td><td>O(1)</td></tr><tr><td>listNextNode</td><td>返回给定节点的后置节点</td><td>O(1)</td></tr><tr><td>listNodeValue</td><td>返回给定节点当前值</td><td>O(1)</td></tr><tr><td>listCreate</td><td>创建不包含任何值的空链表</td><td>O(1)</td></tr><tr><td>listAddNodeHead</td><td>将给定值的新节点添加到表头</td><td>O(1)</td></tr><tr><td>listAddNodeTail</td><td>将给定值的新节点添加到表尾</td><td>O(1)</td></tr><tr><td>listInsertNode</td><td>将给定值的新节点插入到链表指定位置</td><td>O(1)</td></tr><tr><td>listSearchKey</td><td>查找并返回链表中给定值的节点</td><td>O(n)</td></tr><tr><td>listIndex</td><td>返回链表给定索引的节点</td><td>O(n)</td></tr><tr><td>listDelNode</td><td>删除链表给定节点</td><td>O(n)</td></tr><tr><td>listRotate</td><td>将表尾节点弹出并设置成新的表头节点</td><td>O(1)</td></tr><tr><td>listDup</td><td>添加给定链表副本</td><td>O(n)</td></tr><tr><td>listRelease</td><td>释放给定链表</td><td>O(n)</td></tr></tbody></table><h3 id="链表总结"><a href="#链表总结" class="headerlink" title="链表总结"></a>链表总结</h3><ol><li>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li><li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li><li>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li><li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划问题思维导图</title>
    <link href="/RoyalLiang.github.io/2020/06/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <url>/RoyalLiang.github.io/2020/06/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>附图一张<br><img src="http://image.lcremember.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200522224415.png" srcset="/RoyalLiang.github.io/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis设计与实现（1-字符串）</title>
    <link href="/RoyalLiang.github.io/2020/06/01/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%881-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/"/>
    <url>/RoyalLiang.github.io/2020/06/01/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%EF%BC%881-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>每个sds.h/sdshdr结构表示一个SDS值：</p><pre><code class="hljs plain">struct sdshdr&#123;    &#x2F;&#x2F;记录buf数组重已使用字节的数量，等于SDS所保存字符串的长度    int len;    &#x2F;&#x2F;记录buf数组中未使用字节的数量    int free;    &#x2F;&#x2F;字节数组，用来保存字符串    char buf[];&#125;</code></pre><blockquote><p>free属性的值为0，表示这个SDS没有分配任何未使用空间。</p><p>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</p><p>buf属性是一个char类型的数组，最后一个字节保存空字符’\0’。</p><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。</p></blockquote><p>示例：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/330602/1589794936487-625d3192-d976-40a7-ab86-a52da7fef273.png" srcset="/RoyalLiang.github.io/img/loading.gif" alt="yuque_diagram.png"></p><h3 id="SDS与C字符串区别"><a href="#SDS与C字符串区别" class="headerlink" title="SDS与C字符串区别"></a>SDS与C字符串区别</h3><ol><li>C字符串获取长度复杂度为O(n)，SDS为O(1)</li><li>C字符串进行拼接时容易发生缓冲区溢出（拼接时未分配足够的空间，导致数据溢出，覆盖原有数据）</li></ol><blockquote><p>当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作</p></blockquote><ol><li>SDS减少了修改字符串时的内存重分配次数</li></ol><blockquote><p>C字符串每次在拼接或截断字符串时，必须对内存进行重新分配，否则将会造成内存溢出或内存泄露。</p></blockquote><h3 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h3><p>未完待续…</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7 安装Redis6.0</title>
    <link href="/RoyalLiang.github.io/2020/05/13/CentOS7-%E5%AE%89%E8%A3%85Redis6.0/"/>
    <url>/RoyalLiang.github.io/2020/05/13/CentOS7-%E5%AE%89%E8%A3%85Redis6.0/</url>
    
    <content type="html"><![CDATA[<p>今天给一台崭新的服务器(CentOS 7.7)安装Redis时才发现，Redis已经更新到了6.0(手动滑稽)，抱着用心不用旧的心态，立马喜滋滋地下载，上传到服务器上面开始安装，结果刚开始就碰壁了。再次记录一下安装的小坑。本文不讨论Redis6.0的新特性，仅记录安装踩到的坑。</p><h1 id="下载Redis6-0"><a href="#下载Redis6-0" class="headerlink" title="下载Redis6.0"></a>下载Redis6.0</h1><ol><li><p>使用linux wget命令：</p><blockquote><p>wget <a href="http://download.redis.io/releases/redis-6.0.1.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-6.0.1.tar.gz</a></p></blockquote></li><li><p>前往官网下载，使用文件传输工具传输至服务器。</p></li></ol><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>安装Redis需要安装依赖，命令如下：</p><blockquote><p>yum install gcc gcc-c++ -y</p></blockquote><p>需要注意的是，Redis6.0需要gcc版本不能过低，最好5.0版本以上，否则会编译出错。</p><p>升级系统gcc命令如下：</p><ol><li>安装centos-release-scl。</li></ol><blockquote><p>yum install centos-release-scl</p></blockquote><ol start="2"><li>安装devtoolset，注意，如果想安装7.<em>版本的，就改成devtoolset-7-gcc</em>。</li></ol><blockquote><p>yum install devtoolset-8-gcc*</p></blockquote><ol start="3"><li>激活对应的devtoolset，所以你可以一次安装多个版本的devtoolset，需要的时候用下面这条命令切换到对应的版本。</li></ol><blockquote><p>scl enable devtoolset-8 bash</p></blockquote><h1 id="编译、安装"><a href="#编译、安装" class="headerlink" title="编译、安装"></a>编译、安装</h1><p>解压安装包</p><blockquote><p>tar -zxvf 压缩包.tar.gz</p></blockquote><p>进入解压文件夹</p><blockquote><p>cd Redis安装包文件夹</p></blockquote><p>编译、安装</p><blockquote><p>make</p><p>make install </p></blockquote><pre><code class="hljs plain"># 编译make# 安装make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis# PREFIX后的路径可以修改成自己想改的</code></pre><h1 id="添加软链接"><a href="#添加软链接" class="headerlink" title="添加软链接"></a>添加软链接</h1><p>安装完成后，会发现redis-server，redis-cli命令不可用。不用着急。添加两个软连接就可以了，命令如下：</p><pre><code class="hljs plain">添加redis-server软连接ln -s &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;bin&#x2F;redis-server添加redis-cli软连接ln -s &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-scli &#x2F;usr&#x2F;bin&#x2F;redis-cli</code></pre><p>以上就是全文安装教程，特此记录，网上破烂教程太多，坑的我不要不要的。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习笔记 (1)</title>
    <link href="/RoyalLiang.github.io/2020/05/08/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-(1)/"/>
    <url>/RoyalLiang.github.io/2020/05/08/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-(1)/</url>
    
    <content type="html"><![CDATA[<p>第一次接触Redis，已经记不清是什么时候了，那时候对它的唯一印象就是它是数据库，还能做缓存。对于它的底层，数据结构什么的一概不知，更不用说什么缓存，消息通知什么的了。前段时间又系统的看了一遍Redis视频教程和书本教程，在此做个记录。毕竟好记性不如烂笔头。此为开篇。</p><h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p>Redis是基于key-value的存储服务系统，支持多种数据结构，并且是开源的。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li><p>速度快</p><p>Redis速度之所以快的最根本原因，是因为其数据存在内存中。</p></li><li><p>持久化</p><p>以异步的方式将数据保存在硬盘上</p><ul><li>RDB</li><li>AOF</li></ul></li><li><p>多种数据格式</p><ul><li><p>字符串</p></li><li><p>list</p></li><li><p>哈希</p></li><li><p>集合</p></li><li><p>有序集合</p></li><li><p>Bitmaps：位图</p></li><li><p>HyperLogLog：超小内存唯一值计数</p></li><li><p>GEO：地理信息定位</p></li></ul></li><li><p>多功能</p><ul><li>发布订阅</li><li>事务</li><li>Lua脚本</li><li>pipeline</li></ul></li></ol><h2 id="安装-启动"><a href="#安装-启动" class="headerlink" title="安装/启动"></a>安装/启动</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="hljs plain"># Linux# 获取安装包wget 安装包链接# 解压tar -zxvf 安装包# 添加软连接ln -s 安装包 redis# 安装cd redismake &amp;&amp; make install</code></pre><p>Redis目录可执行文件说明：</p><ul><li>redis-server: Redis服务器</li><li>redis-cli: Redis命令行客户端</li><li>redis-benchmark：Redis性能测试工具</li><li>redis-check-aof：AOF文件修复工具</li><li>redis-check-dump：RDB文件修复工具</li><li>redis-sentinel：Sentinel服务器</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>最简启动</p><blockquote><p>redis-server</p></blockquote><p>动态参数启动</p><blockquote><p>redis-server –port xxx –host xxx.xxx.xxx.xxx –a password</p></blockquote><p>配置文件启动</p><blockquote><p>redis-server /xxx/xxx/conf/redis-xxx.conf</p></blockquote><h2 id="常用-最简-配置"><a href="#常用-最简-配置" class="headerlink" title="常用(最简)配置"></a>常用(最简)配置</h2><ul><li>daemonize：是否守护进程(no | yes)</li><li>port：对外端口号</li><li>logfile： 系统日志文件</li><li>dir：工作目录</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Supervisor使用教程</title>
    <link href="/RoyalLiang.github.io/2020/05/08/%E4%B8%87%E8%83%BD%E7%9A%84supervisor%EF%BC%8C%E6%89%98%E8%B5%B7%E4%BA%86%E6%97%A0%E6%95%B0%E4%B8%AA%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F/"/>
    <url>/RoyalLiang.github.io/2020/05/08/%E4%B8%87%E8%83%BD%E7%9A%84supervisor%EF%BC%8C%E6%89%98%E8%B5%B7%E4%BA%86%E6%97%A0%E6%95%B0%E4%B8%AA%E5%90%8E%E5%8F%B0%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="supervisor简介"><a href="#supervisor简介" class="headerlink" title="supervisor简介"></a>supervisor简介</h1><blockquote><p>Supervisor is a client/server system that allows its users to monitor and control a number of processes on UNIX-like operating systems.</p><p>It shares some of the same goals of programs like launchd, daemontools, and runit. Unlike some of these programs, it is not meant to be run as a substitute for <code>init</code> as “process id 1”. Instead it is meant to be used to control processes related to a project or a customer, and is meant to start like any other program at boot time.</p><p>官方文档：<a href="[*文档在此*](http://supervisord.org/)">点击此处</a></p></blockquote><p>以上摘自官网，简单来说，supervisor是一个基于Python开发的通用的进程管理程序，是Linux/Unix系统上的进程监控工具，可以管理和监控Linux上面的进程，能将一个普通的命令行进程变为后台daemon，并监控进程状态。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>直接使用pip安装</p><blockquote><p>pip install supervisor</p></blockquote></li></ol><ol start="2"><li><p>使用easy_install</p><blockquote><p>yum/apt-get install python-setuptools</p><p>easy_install supervisor</p></blockquote></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装完成后首先设置配置文件</p><pre><code class="hljs python">echo_supervisord_conf &gt; 目标文件夹/supervisod.conf</code></pre><p>设置配置文件（最简配置）</p><pre><code class="hljs python">[inet_http_server] port=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">9001</span>;<span class="hljs-comment"># 开启web server，外网访问请设置成0.0.0.0 </span> [supervisorctl]serverurl=unix:///tmp/supervisor.sock ; serverurl=http://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">9001</span> ; [include]files = *.ini<span class="hljs-comment"># 包含当前目录下的所有.ini的配置文件</span></code></pre><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>supervisor包含命令行与网页模式。</p><p>supervisorctl：命令行工具，提供一个类似shell的操作接口，通过它你可以连接到不同的supervisord进程上来管理它们各自的子程序，命令通过UNIX socket或者TCP来和服务通讯。</p><p>相关命令：</p><blockquote><p>status：查看当前所有托管程序列表</p><p>update： 更新所有/选择程序状态</p><p>reload：重启supervisor</p><p>start 【program_name】：启动某个进程</p><p>restart 【program_name】：重启某个进程</p><p>stop 【program_name】：停止【program_name】进程</p><p>stop groupworker：重启所有属于名为groupworker这个分组的进程(start,restart同理)</p><p>stop all：停止全部进程，注：start、restart、stop都不会载入最新的配置文</p><p>reread：当一个服务由自动启动修改为手动启动时执行一下就ok</p></blockquote><p>Web Server：通过web控制进程。</p><blockquote><p>PS：需要设置[inet_http_server]配置项</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><blockquote><p>supervisord -c supervisor配置文件夹/supervisord.conf</p></blockquote><h1 id="托管程序配置文件示例"><a href="#托管程序配置文件示例" class="headerlink" title="托管程序配置文件示例"></a>托管程序配置文件示例</h1><blockquote><p>test.ini</p></blockquote><pre><code class="hljs plain">[program:显示名称]command&#x3D;x x x;需要执行的命令，可携带路径directory&#x3D;XXX&#x2F;XXX       ; 工作路径priority&#x3D;999                  ; 优先级，默认999startsecs &#x3D; 5        ; 启动 5 秒后没有异常退出，则认为正常启动autorestart &#x3D; true   ; 程序异常退出后自动重启startretries &#x3D; 3     ; 启动失败自动重试次数，默认3enviroment&#x3D;PATH&#x3D;&quot;使用环境&quot;;例如：&#x2F;xxx&#x2F;xxx&#x2F;虚拟环境&#x2F;bin&#x2F;stdout_logfile &#x3D; &#x2F;xxx&#x2F;logs&#x2F;scheduler.log;输出日志stderr_logfile &#x3D; &#x2F;xxx&#x2F;logs&#x2F;scheduler_err.log;错误输出日志#把stderr重定向到stdout，默认 falseredirect_stderr &#x3D; false# 防止出现僵尸进程stopasgroup&#x3D;truekillasgroup&#x3D;true</code></pre><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>配置参数介绍</p><pre><code class="hljs plain">[unix_http_server]file&#x3D;&#x2F;tmp&#x2F;supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用;chmod&#x3D;0700                 ;socket文件的mode，默认是0700;chown&#x3D;nobody:nogroup       ;socket文件的owner，格式：uid:gid ;[inet_http_server]         ;HTTP服务器，提供web管理界面;port&#x3D;127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性;username&#x3D;user              ;登录管理后台的用户名;password&#x3D;123               ;登录管理后台的密码 [supervisord]logfile&#x3D;&#x2F;tmp&#x2F;supervisord.log ;日志文件，默认是 $CWD&#x2F;supervisord.loglogfile_maxbytes&#x3D;50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小logfile_backups&#x3D;10           ;日志文件保留备份数量默认10，设为0表示不备份loglevel&#x3D;info                ;日志级别，默认info，其它: debug,warn,tracepidfile&#x3D;&#x2F;tmp&#x2F;supervisord.pid ;pid 文件nodaemon&#x3D;false               ;是否在前台启动，默认是false，即以 daemon 的方式启动minfds&#x3D;1024                  ;可以打开的文件描述符的最小值，默认 1024minprocs&#x3D;200                 ;可以打开的进程数的最小值，默认 200 [supervisorctl]serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致;serverurl&#x3D;http:&#x2F;&#x2F;127.0.0.1:9001 ; 通过HTTP的方式连接supervisord ; [program:xx]是被管理的进程配置参数，xx是进程的名称[program:xx]command&#x3D;&#x2F;opt&#x2F;apache-tomcat-8.0.35&#x2F;bin&#x2F;catalina.sh run  ; 程序启动命令autostart&#x3D;true       ; 在supervisord启动的时候也自动启动startsecs&#x3D;10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒autorestart&#x3D;true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启startretries&#x3D;3       ; 启动失败自动重试次数，默认是3user&#x3D;tomcat          ; 用哪个用户启动进程，默认是rootpriority&#x3D;999         ; 进程启动优先级，默认999，值小的优先启动redirect_stderr&#x3D;true ; 把stderr重定向到stdout，默认falsestdout_logfile_maxbytes&#x3D;20MB  ; stdout 日志文件大小，默认50MBstdout_logfile_backups &#x3D; 20   ; stdout 日志文件备份数，默认是10; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile&#x3D;&#x2F;opt&#x2F;apache-tomcat-8.0.35&#x2F;logs&#x2F;catalina.outstopasgroup&#x3D;false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程killasgroup&#x3D;false     ;默认为false，向进程组发送kill信号，包括子进程 ;包含其它配置文件[include]files &#x3D; relative&#x2F;directory&#x2F;*.ini    ;可以指定一个或多个以.ini结束的配置文件</code></pre>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重拾Hexo主题博客</title>
    <link href="/RoyalLiang.github.io/2020/04/20/%E9%87%8D%E6%8B%BEHexo/"/>
    <url>/RoyalLiang.github.io/2020/04/20/%E9%87%8D%E6%8B%BEHexo/</url>
    
    <content type="html"><![CDATA[<p>去年6月份，接触到了hexo静态博客，一时兴起之下，就跟着教程搭了一个。但只是搭了一个，之后就再也没用过了。一个月之前我便在思考重试起我的博客网站，但依然没想好是使用前后端分离，还是直接使用模板语言，亦或是hexo。一个月后，终于决定还是使用hexo搭建，一时多熟悉一下hexo，第二也是最重要的一点是，想要借助静态博客，锻炼一下我的markdown写作能力，好了，正文开始，此篇为记录下搭建过程。<br><strong>本文不介绍详细安装过程</strong></p><h1 id="工具-环境搭建"><a href="#工具-环境搭建" class="headerlink" title="工具/环境搭建"></a>工具/环境搭建</h1><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>由于hexo基于nodejs，所以在使用hexo之前需要安装nodejs，安装nodejs方法这里不再赘述，各位看官直接网搜教程即可<br><strong>PS:尽量安装最新/稳定版本的nodejs</strong></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>安装好node之后，就可以安装hexo了。打开Terminal，输入npm i hexo-cli -g，等待安装结束后，hexo便安装好了。<br><strong>如果嫌弃安装速度过慢的话，可以配置一下npm的国内下载源，这里不再赘述，直接搜淘宝npm</strong></p><h2 id="使用github"><a href="#使用github" class="headerlink" title="使用github"></a>使用github</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>没有过github经历的朋友，先去网上搜一下github(国内访问可能会慢)，跟着网站指引，注册一个账号后在本级下载git工具。下载地址:<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">官网下载</a></p><h3 id="设置git"><a href="#设置git" class="headerlink" title="设置git"></a>设置git</h3><p>下载之后设置邮箱、用户名、ssh-key，将public-key添加到git我的ssh—key中即可，这里不再赘述，命令如下：<br><code>git config --global user.name &quot;你的git用户名&quot;git config --global user.email &quot;用来注册git的邮箱号码&quot;生成密钥SSH key：ssh-keygen -t rsa -C &quot;用来注册git的邮箱号码&quot;生成的ssh-key路径在C://users/电脑用户名/.ssh/下的rsa_pub(Windows)，Mac/Linux的路径为~/.ssh/id_rsa.pub</code></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>上述操作做好之后，将你的公钥配置在git中即可。<br>之后新建仓库，名称随意，但在名字后必须加上.github.io。且仓库需要是公共仓库。</p><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><p>创建仓库之后，点击仓库右上角的setting按钮，页面下拉，找到github page，点击choose themes即可开始使用github静态博客。</p><h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><p>添加一个博客目录，例如c://projects/hexoproject<br>在该路径打开Terminal，执行如下命令：<br>初始化hexo博客<br><code>hexo inithexo g</code><br>启动服务<br><code>hexo s</code><br>上传到git(需要先配置config文件)<br><code>hexo d</code></p><h3 id="设置博客配置git"><a href="#设置博客配置git" class="headerlink" title="设置博客配置git"></a>设置博客配置git</h3><p>打开博客根目录下的_config.yml文件，找到最后修改为：</p><pre><code class="hljs plain">deploy:  type: git  repository: https:&#x2F;&#x2F;github.com&#x2F;用户名&#x2F;项目名.github.io  branch: master</code></pre><p>配置完成后即可使用hexo d命令</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>购买域名，实名认证、域名备案为前提。<br>解决完上述问题之后，打开域名控制台，设置域名解析，添加两个CNAME解析，主机记录分别为www和@，记录值都是项目名称xxx.github.io<br>完成后，在git项目页面点击setting，下拉找到custom domain，将其值设置为你的域名，点击保存即可。<br>以上即为本文的全部内容，只是记录博客的基本设置，进阶设置各位看官直接百度即可。好了，再见～</p><p><img src="https://rookies.oss-cn-shanghai.aliyuncs.com/SC04C06.jpg" srcset="/RoyalLiang.github.io/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
