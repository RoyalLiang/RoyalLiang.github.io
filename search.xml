<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入 dict 机制，转化类变量</title>
      <link href="/RoyalLiang.github.io/post/828dc49d.html"/>
      <url>/RoyalLiang.github.io/post/828dc49d.html</url>
      
        <content type="html"><![CDATA[<h3 align=center>前言</h3><p>一般情况下，我们在初始化 <code>dict</code> （字典）时会直接 <code>&#123;key: value&#125;</code> 这么定义，亦或是使用 <code>dict(key=value)</code> 定义使用。而当处理对象变成了在一个类，在使用 <code>obj.__dict__</code> 魔法函数时，我们拿到的将会是这个类的实例变量，定义在类体中的类变量，我们是无法直接获取到的。</p><h3 align=center>纷争开始</h3><p>要想实现以 <code>dict</code> 的方式读取类&#x2F;实例变量，我们duck不必使用库或其他依赖。下面我们看个例子：</p><p><img src="https://cdn.notfound.icu/shares/1.png"></p><p>上述代码在实际运行时，将会得到 <code>TypeError: ‘A’ object is not iterable</code> 的错误。这是因为 <code>dict</code> 对象是需要可迭代的，也就是需要属于 <code>iter</code>，或者实现其所有方法。</p><p>我们再看一个例子：</p><p><img src="https://cdn.notfound.icu/shares/2.png"></p><p>当我们在 <code>keys</code> 这个方法上打上断点，以断点调试的方法运行程序时会发现，程序将会停在这一行代码上。这是因为，在默认情况下，我们在将对象直接传给 <code>dict</code> 的时候，<code>dict</code> 将会去这个类里寻找 <code>keys</code> 方法，以期望拿到字典的所有键。而这些键是由我们自己定义并返回的。再看下面的例子：</p><p><img src="https://cdn.notfound.icu/shares/3.png"></p><p>运行上述代码我们将会得到 <code>TypeError: &#39;A&#39; object is not subscriptable</code> 的错误。这是因为，在默认情况下我们无法以中括号的方式去访问一个对象，但是我们可以使用一个方法，以改变这种情况。再看下面的例子：</p><p><img src="https://cdn.notfound.icu/shares/4.png"></p><p>运行代码之后将会发现，代码不再报错并且打印出来的数值与 <code>__getitem___</code> 所返回的值一样。这就是使用中括号调用的结果。如果我们想拿到某个变量所对应的值，我们可以使用 <code>getattr</code>。如下所示：</p><p><img src="https://cdn.notfound.icu/shares/5.png"></p><p>上述代码将会打印出：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们已经将对象以字典的方法拿到了类里的变量，不论类变量还是实例变量。</p><h3 align=center>片尾</h3><p>以上便是本次文章的所有内容，介绍了如何以 <code>dict</code> 的方式访问实例变量。并没有同时介绍以对象的方式读取 <code>dict</code> 数据，因为反过来我们可以很容易的实现这个需求，这里推荐使用 <code>namedtuple</code> 内置库。</p><p>本文不涉及 <code>dict </code> 的基础知识以及底层原理，毕竟网上教程已经非常之充实了，这里不再赘述。</p><p><strong>dict 的键，必须是可 hash 的。</strong>这是 <code>dict</code> 非常重要的一点。</p>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建博客，关于建站方式的一些事儿</title>
      <link href="/RoyalLiang.github.io/post/c6eb7597.html"/>
      <url>/RoyalLiang.github.io/post/c6eb7597.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>关于博客自建，网上已经有很多详细的教程了，但看到这些教程的前提是咱自个儿得知道博客的搭建方式是什么。是自有服务器搭建？还是挂载第三方搭建？是自己写代码还是别的方式等等。</p><p>本文将会列出几种常用的博客搭建的方式，下面正文开始。</p><h3 align='center'>WordPress</h3><p><strong>这是每一个博主都跳不过的搭建方法。</strong></p><p>目前大多数的博客网站都是基于<code>WordPress</code>来搭建的。通过它我们可以很方便的搭建属于自己的博客网站。</p><p>一方面，它很<strong>重</strong>，需要进行繁多的配置。另一方面，自有<strong>服务器</strong>是基础。</p><p>得益于<code>Docker</code>容器化，现在可以很方便的部署<code>WordPress</code>程序，不再需要我们自己手动安装<code>PHP</code>以及其他依赖来部署。</p><p><strong>写作 - 部署方式</strong></p><ol><li>点击 文章标签，新建文章。</li><li>输入文章内容，选择号分类和标签。</li><li>发布。</li></ol><p><strong>网站截图：</strong></p><p>前端：</p><p><img src="https://cdn.notfound.icu/hexo/wordpress1.png"></p><p>博客后台:</p><p><img src="https://cdn.notfound.icu/hexo/wordpress.png"></p><h3 align='center'>Vuepress/Vitepress</h3><p><strong>这是现在很流行的一种搭建方法。</strong></p><p>现在有很多博主选择使用这种方式来搭建自己的博客，简洁，轻便。许多公司的技术、接口等文档也都是基于这种方式。</p><p>它需要我们有点代码基础。</p><p>它可以部署在自己的服务器上，也可以挂载到第三方服务（Github Pages等。）</p><p>挂载到第三方如 <code>GitHub Pages</code> 时，需要我们了解<code>Git</code>的一些基本知识。</p><p>它可以定制化网页内容。可以使用第三方主题。</p><p><strong>写作 - 部署方式</strong></p><ol><li>编写 <code>markdown</code> 文件。</li><li>（外挂）使用 <code>git</code> 命令同步至仓库即可；</li><li>（服务器）将文件上传至指定目录。</li><li>（服务器）使用命令编译。</li><li>（服务器）重启博客服务。</li></ol><p><strong>网站截图：</strong></p><p>这是用<code>Vuepress</code>搭建的文档截图：</p><p><img src="https://cdn.notfound.icu/hexo/vuepress.jpg"></p><p>这是用<code>Vuepress</code>搭建的博客截图：</p><p><img src="https://cdn.notfound.icu/hexo/vuepress3.png"></p><h3 align='center'>Hexo</h3><p><strong>这是外挂到 GitHub 的一种方式。</strong></p><p><code>Hexo</code>是基于<code>Node.js</code>的一种轻便博客搭建方式。</p><p>它需要外挂到第三方服务；需要熟悉 <code>markdown</code>写作；还需要熟悉一些 <code>git</code>的常用命令以及 <code>Github Pages</code>的部署方式。</p><p>它需要我们了解一些代码知识。</p><p>它可以定制化网页内容。有非常庞大的主题库。</p><p><strong>写作 - 部署方式：</strong></p><ol><li>编写 <code>markdown</code> 文件。</li><li>使用 <code>hexo</code> 命令进行编译与上传。</li><li>等待网站刷新即可显示最新文章。</li></ol><p><strong>网站截图:</strong></p><p><img src="https://cdn.notfound.icu/hexo/hexo.png"></p><h3 align='center'>自写博客程序</h3><p><strong>这是需要有一定的代码基础的一种方式。</strong></p><p>它需要很多的代码知识，包括但不限于前端、后端、数据库。</p><p>它需要自己编写前端代码、后端代码并完成前后端联调。</p><p>它可以使用模板语言，也可以使用前后端分离的方式，全凭喜好。</p><p>它长什么样，全看自己如何编码。</p><p><strong>写作 - 部署方式：</strong></p><ol><li>后台编辑文章。</li><li>点击发布。</li><li>刷新前端页面。</li></ol><p><strong>网站截图：</strong></p><p><img src="https://cdn.notfound.icu/hexo/111.png"></p><p>以上便是本次文章的所有内容，仅列举了实操过的几种搭建方式，不涉及详细操作过程。如果有时间，我会专门介绍一下以上各种方式的详细搭建过程。以及域名、服务器&#x2F;vps  购买，备案，域名解析等全流程。</p><p>各位看官，咱们下次再见~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 王婆卖瓜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 设计与实现(11-事件)</title>
      <link href="/RoyalLiang.github.io/post/891b59ea.html"/>
      <url>/RoyalLiang.github.io/post/891b59ea.html</url>
      
        <content type="html"><![CDATA[<p>Redis 服务器是一个 <code>事件驱动程序</code>，服务器需要处理以下两类事件：</p><ul><li>文件事件（file event）：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对 <code>套接字操作</code> 的抽象。服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</li><li>时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类 <code>定时操作</code> 的抽象。</li></ul><h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis 基于 <code>Reactor</code> 模式开发了自己的网络事件处理器：这个处理器被称为 <code>文件事件处理器</code>（fileevent handler）：</p><ul><li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>虽然文件事件处理器以单线程方式运行，但通过使用I&#x2F;O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p><h4 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h4><p>下图展示了文件事件处理器的四个组成部分，它们分别是套接字、I&#x2F;O多路复用程序、文件事件分派器（dispatcher），以及事件处理器。</p><p><img src="https://cdn.notfound.icu/hexo/1593608323977-c1471925-8ac2-4435-ac9b-ef68286cb128.png" alt="img"></p><p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p>I&#x2F;O多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但I&#x2F;O多路复用程序总是会将所有产生事件的套接字都放到一个队列里面，然后通过这个队列，以 <code>有序</code>（sequentially）、<code>同步</code>（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件处理完毕之后，I&#x2F;O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p><p>文件事件分派器接收I&#x2F;O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。</p><p>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数，它们定义了某个事件发生时，服务器应该执行的动作。</p><h4 id="I-x2F-O多路复用程序的实现"><a href="#I-x2F-O多路复用程序的实现" class="headerlink" title="I&#x2F;O多路复用程序的实现"></a>I&#x2F;O多路复用程序的实现</h4><p>Redis 的 I&#x2F;O 多路复用程序的所有功能都是通过包装常见的 select、epoll、evport 和 kqueue 这些 I&#x2F;O 多路复用函数库来实现的，每个 I&#x2F;O 多路复用函数库在Redis 源码中都对应一个单独的文件。</p><p>Redis 在 I&#x2F;O多 路复用程序的实现源码中用 #include 宏定义了相应的规则，程序会在编译时自动选择系统中性能最高的I&#x2F;O多路复用函数库来作为 Redis 的 I&#x2F;O 多路复用程序的底层实现。</p><h4 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h4><p>I&#x2F;O 多路复用程序可以监听多个套接字的 <code>ae.h/AE_READABLE</code> 事件和 <code>ae.h/AE_WRITABLE</code> 事件，这两类事件和套接字操作之间的对应关系如下：</p><ul><li>当套接字变得可读（客户端 write 套接字），或者有新的可应答（acceptable）套接字出现时（客户端 connect 服务器的监听套接字），套接字产生AE_READABLE 事件。</li><li>当套接字变得可写时（客户端 read 套接字），套接字产生 AE_WRITABLE 事件。</li></ul><p>I&#x2F;O 多路复用程序允许服务器同时监听套接字的 AE_READABLE 事件和 AE_WRITABLE 事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会先读后写。</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>ae.c&#x2F;aeCreateFileEvent 函数接受一个套接字描述符、一个事件类型，以及一个事件处理器作为参数，将给定套接字的给定事件加入到I&#x2F;O多路复用程序的监听范围之内，并对事件和事件处理器进行关联。</p><p>ae.c&#x2F;aeDeleteFileEvent 函数接受一个套接字描述符和一个监听事件类型作为参数，让I&#x2F;O多路复用程序取消对给定套接字的给定事件的监听，并取消事件和事件处理器之间的关联。ae.c&#x2F;aeGetFileEvents 函数接受一个套接字描述符，返回该套接字正在被监听的事件类型：</p><ul><li><p>如果套接字没有任何事件被监听，那么函数返回 AE_NONE。</p></li><li><p>如果套接字的读事件正在被监听，那么函数返回 AE_READABLE。</p></li><li><p>如果套接字的写事件正在被监听，那么函数返回 AE_WRITABLE。</p></li><li><p>如果套接字读和写事件正在被监听，那么函数返回 AE_READABLE|AE_WRITABLE。</p></li></ul><p>ae.c&#x2F;aeWait 函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数，给定时间内阻塞并等待套接字的给定类型事件产生，当事件成功产生&#x2F;等待超时，函数返回。</p><p>ae.c&#x2F;aeApiPoll 函数接受一个 sys&#x2F;time.h&#x2F;struct timeval 结构为参数，并在指定时间內，阻塞并等待所有被 aeCreateFileEven 函数设置为监听状态的套接字产生文件事件，当有至少一个事件产生&#x2F;等待超时，函数返回。</p><p>ae.c&#x2F;aeProcessEvents 函数是文件事件分派器，它先调用 aeApiPoll 函数来等待事件产生，然后遍历所有已产生的事件，并调用相应的事件处理器来处理这些事件。</p><p>ae.c&#x2F;aeGetApiName 函数返回I&#x2F;O多路复用程序底层所使用的 I&#x2F;O 多路复用函数库的名称：返回 “epoll” 表示底层为 epoll 函数库，返回 “select” 表示底层为 select 函数库，诸如此类。</p><h4 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h4><p>Redis 为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p><ul><li><p>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</p></li><li><p>为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</p></li><li><p>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</p></li><li><p>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</p></li></ul><p>在这些事件处理器里面，服务器最常用的要数与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。</p><p>客户端与服务端通信：</p><p><img src="https://cdn.notfound.icu/hexo/1594038971011-a9c1bf57-1d73-41d5-a285-b16650fc7d8d.png" alt="img"></p><h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>Redis 的时间事件分为以下两类：</p><ul><li>定时事件：让一段程序在指定的时间之后执行一次。</li><li>周期性事件：让一段程序每隔指定时间就执行一次。</li></ul><p>一个时间事件主要由以下三个属性组成：</p><ul><li><p>id：服务器为时间事件创建的全局唯一ID。ID号按从小到大的顺序递增。</p></li><li><p>when：毫秒精度的UNIX时间戳，记录了时间事件的到达（arrive）时间。</p></li><li><p>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</p></li></ul><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值：</p><ul><li>如果事件处理器返回 ae.h&#x2F;AE_NOMORE，那么这个事件为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li><li>如果事件处理器返回一个非 AE_NOMORE 的整数值，那么这个事件为周期性时间：当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的 when 属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。比如说，如果一个时间事件的处理器返回整数值30，那么服务器应该对这个时间事件进行更新，让这个事件在30毫秒之后再次到达。</li></ul><p><strong>目前版本的 Redis 只使用周期性事件，而没有使用定时事件。</strong></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p><p>保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说，该链表不按 when 属性的大小排序。</p><h4 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h4><h4 id="时间事件应用实例：serverCron函数"><a href="#时间事件应用实例：serverCron函数" class="headerlink" title="时间事件应用实例：serverCron函数"></a>时间事件应用实例：serverCron函数</h4><p>持续运行的 Redis 服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由 redis.c&#x2F;serverCron 函数负责执行，它的主要工作包括：</p><ul><li><p>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</p></li><li><p>清理数据库中的过期键值对。</p></li><li><p>关闭和清理连接失效的客户端。</p></li><li><p>尝试进行 AOF 或 RDB 持久化操作。</p></li><li><p>如果服务器是主服务器，那么对从服务器进行定期同步。</p></li><li><p>如果处于集群模式，对集群进行定期同步和连接测试。</p></li></ul><p>Redis 服务器以周期性事件的方式来运行 serverCron 函数，在服务器运行期间，每隔一段时间，serverCron 就会执行一次，直到服务器关闭为止。</p><p>可以通过修改 hz 选项来调整 serverCron 的每秒执行次数。</p><h3 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h3><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度。事件的调度和执行由 ae.c&#x2F;aeProcessEvents 函数负责，以下是该函数的伪代码表示：</p><p><img src="https://cdn.notfound.icu/hexo/1594199786127-569717f6-2270-4928-8472-25f168bac56d.png" alt="img"></p><p>在实际中，处理已产生文件事件的代码直接写在 aeProcessEvents 函数里面。</p><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，这就构成了 Redis 服务器的主函数。</p><p>一次完整的事件调度和执行过程:</p><p><img src="https://cdn.notfound.icu/hexo/1594200077588-b60f020b-16c3-46cb-a145-708a62252326.png" alt="img"></p><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul><li><p>Redis 服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。</p></li><li><p>文件事件处理器是基于 Reactor 模式实现的网络通信程序。</p></li><li><p>文件事件是对套接字操作的抽象：每次套接字变为可应答（acceptable）、可写（writable）或者可读（readable）时，相应的文件事件就会产生。</p></li><li><p>文件事件分为 AE_READABLE 事件（读事件）和 AE_WRITABLE 事件（写事件）两类。</p></li><li><p>时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</p></li><li><p>服务器在一般情况下只执行 serverCron 函数一个时间事件，并且这个事件是周期性事件。</p></li><li><p>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</p></li><li><p>时间事件的实际处理时间通常会比设定的到达时间晚一些。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 设计与实现(10-AOF持久化)</title>
      <link href="/RoyalLiang.github.io/post/1fb2784e.html"/>
      <url>/RoyalLiang.github.io/post/1fb2784e.html</url>
      
        <content type="html"><![CDATA[<p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的。</p><p>AOF持久化保存数据库状态的方法是将服务器执行的SET、SADD、RPUSH三个命令保存到AOF文件中。被写入AOF文件的所有命令以Redis的命令请求协议格式保存。</p><h3 id="持久化的实现"><a href="#持久化的实现" class="headerlink" title="持久化的实现"></a>持久化的实现</h3><p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p><h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>当AOF持久化功能打开时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">//AOF 缓冲区</span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="文件的写入与同步"><a href="#文件的写入与同步" class="headerlink" title="文件的写入与同步"></a>文件的写入与同步</h4><p>Redis的服务器进程就是一个事件循环（loop），循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，时间事件则负责执行像serverCron函数这样需要定时运行的函数。</p><p>由于服务器在处理文件事件时可能会执行写命令，使得命令被追加到aof_buf缓冲区里面，所以服务器每次结束一个事件循环之前，都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面，这个过程可以用以下伪代码表示：<img src="https://cdn.notfound.icu/hexo/1593605142665-dae8d09d-8589-467a-abd9-da4e3ba6cf07.png" alt="img"></p><p>flushAppendOnlyFile函数的行为由服务器配置的appendfsync选项的值来决定，各个不同值产生的行为如下所示：</p><table><thead><tr><th>appendfsync选项的值</th><th>flushAppendOnlyFile函数的行为</th></tr></thead><tbody><tr><td>always</td><td>aof_buf所有内容写入并同步到AOF文件</td></tr><tr><td>everysec</td><td>aof_buf所有内容写入到AOF文件，若上次同步时间距离现在超过1秒钟，则再次对AOF文件同步，这个同步操作由一个线程专门负责执行</td></tr><tr><td>no</td><td>aof_buf所有内容写入到AOF文件但不同步，由操作系统决定何时同步</td></tr></tbody></table><p>注：appendfsync选项的默认值为everysec。</p><p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。</p><p>这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>为此，系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p><h5 id="AOF持久化的效率和安全性"><a href="#AOF持久化的效率和安全性" class="headerlink" title="AOF持久化的效率和安全性"></a>AOF持久化的效率和安全性</h5><p>服务器配置appendfsync选项的值直接决定AOF持久化功能的效率和安全性。</p><ul><li><p>当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件并同步，所以always的效率是最慢的，但安全性是最高的。</p></li><li><p>当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每一秒就在子线程中对AOF文件进行一次同步。everysec效率足够快。</p></li><li><p>当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，由操作系统控制何时同步。因为处于no模式下的flushAppendOnlyFile调用无须执行同步操作，所以该模式下的AOF文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no模式和everysec模式的效率类似。</p></li></ul><h3 id="AOF文件的载入与数据还原"><a href="#AOF文件的载入与数据还原" class="headerlink" title="AOF文件的载入与数据还原"></a>AOF文件的载入与数据还原</h3><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p><ol><li><p>创建一个不带网络连接的伪客户端（fake client）：因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令。</p></li><li><p>从AOF文件中分析并读取出一条写命令。</p></li><li><p>使用伪客户端执行被读出的写命令。</p></li><li><p>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</p></li></ol><h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF持久化是通过保存被执行的写命令来记录数据库状态，随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p><p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p><h4 id="AOF文件重写的实现"><a href="#AOF文件重写的实现" class="headerlink" title="AOF文件重写的实现"></a>AOF文件重写的实现</h4><p>虽然Redis将生成新AOF文件替换旧AOF文件的功能命名为“AOF文件重写”，但实际上，AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><p>aof_rewrite函数生成的新AOF文件只包含还原当前数据库状态所必须的命令，所以新AOF文件不会浪费任何硬盘空间。</p><p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h&#x2F;REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。</p><p>在目前版本中，REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值为64，也就是说，如果一个上述键包含了超过64个元素，那么重写程序会用多条命令来记录这个集合，并且每条命令设置的元素数量也为64个。</p><h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>AOF重写程序被Redis放到子进程里执行，这样做可以同时达到两个目的：</p><ul><li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li><li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。不过，因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。</li></ul><p>为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。</p><p>也就是说，在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：</p><ol><li><p>执行客户端发来的命令。</p></li><li><p>将执行后的写命令追加到AOF缓冲区。</p></li><li><p>将执行后的写命令追加到AOF重写缓冲区。这样一来可以保证：</p></li></ol><ul><li><ul><li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li><li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。</li></ul></li></ul><p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p><ol><li>将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。</li><li>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</li></ol><p>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</p><p><img src="https://cdn.notfound.icu/hexo/1593607713707-af235d16-7123-416d-bef8-a1da300023ae.png" alt="img"></p><p>以上就是AOF后台重写，也即是BGREWRITEAOF命令的实现原理。</p><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul><li><p>AOF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。</p></li><li><p>AOF文件中的所有命令都以Redis命令请求协议的格式保存。</p></li><li><p>命令请求会先保存到AOF缓冲区里面，之后再定期写入并同步到AOF文件。</p></li><li><p>appendfsync选项的不同值对AOF持久化功能的安全性以及Redis服务器的性能有很大的影响。</p></li><li><p>服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态。</p></li><li><p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</p></li><li><p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</p></li><li><p>在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 设计与实现(9-RDB持久化)</title>
      <link href="/RoyalLiang.github.io/post/d66f2976.html"/>
      <url>/RoyalLiang.github.io/post/d66f2976.html</url>
      
        <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>为了方便起见，将服务器中的非空数据库以及它们的键值对统称为数据库状态。</p><p>为了解决服务器进程退出，数据库状态也会消失不见的问题，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。</p><p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。</p><p>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。</p><h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE。</p><ul><li>SAVE：阻塞Redis服务器进程，直到RDB文件创建完毕为止。</li><li>BGSAVE：派生出一个子进程，由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。</li></ul><p>创建RDB文件的实际工作由rdb.c&#x2F;rdbSave函数完成，SAVE命令和BGSAVE命令会以不同的方式调用这个函数，两个方法的区别如下伪代码所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def save():</span><br><span class="line">    rdbSave()</span><br><span class="line"></span><br><span class="line">def bgsave():</span><br><span class="line">    # 创建子进程</span><br><span class="line">    pid = fork()</span><br><span class="line">    if pid == 0:</span><br><span class="line">        # 子进程创建RDB文件</span><br><span class="line">        rdbSave()</span><br><span class="line">        # 完成后向父进程发送信号</span><br><span class="line">        signal_parent()</span><br><span class="line">    elif pid &gt; 0:</span><br><span class="line">        # 父进程继续处理请求命令</span><br><span class="line">        handle_request_and _write()</span><br><span class="line">    else:</span><br><span class="line">        # 处理出错情况</span><br><span class="line">        handle_fork_error()</span><br></pre></td></tr></table></figure><p>RDB文件的载入工作是在服务器启动时自动执行的，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。</p><p>值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：</p><ul><li>如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。</li><li>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。</li></ul><p>载入RDB文件的实际工作由rdb.c&#x2F;rdbLoad函数完成。</p><p>在BGSAVE命令执行期间，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令的方式和平时有所不同。</p><ol><li>BGSAVE命令执行期间，SAVE命令会被服务器拒绝，防止产生竞争条件。</li><li>BGSAVE命令执行期间，BGSAVE命令会被服务器拒绝，防止产生竞争条件。</li></ol><p>BGREWRITEAOF和BGSAVE两个命令不能同时执行：</p><ul><li>如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。</li><li>如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。</li></ul><p>PS：服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><p>因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。</p><p>用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。</p><p>默认配置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>只要满足以上三个条件中的任意一个，BGSAVE命令就会被执行：</p><ul><li><p>服务器在900秒之内，对数据库进行了至少1次修改。</p></li><li><p>服务器在300秒之内，对数据库进行了至少10次修改。</p></li><li><p>服务器在60秒之内，对数据库进行了至少10000次修改。</p></li></ul><h4 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h4><p>当Redis服务器启动时，用户可以通过指定配置文件或者传入启动参数的方式设置save选项，如果用户没有主动设置save选项，那么服务器会为save选项设置默认条件。</p><p>接着，服务器程序会根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">//记录保存条件的数组</span><br><span class="line">    struct saveparam *saveparams;</span><br><span class="line">&#125;;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，</span><br><span class="line">每个saveparam结构都保存了一个save选项设置的保存条件</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">struct saveparam &#123;</span><br><span class="line">//秒数</span><br><span class="line">    time_t seconds;</span><br><span class="line">    //修改数</span><br><span class="line">    int changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h4><p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性：</p><ul><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。</li><li>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">//修改计数器</span><br><span class="line">    long long dirty;</span><br><span class="line">    //上一次执行保存的时间</span><br><span class="line">    time_t lastsave;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h4><p>Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。</p><p><img src="https://cdn.notfound.icu/hexo/1593512104215-0bb0280a-d9a4-4469-abd6-c5d82e6b8f64.png" alt="img"></p><p>程序会遍历并检查saveparams数组中的所有保存条件，只要有任意一个条件被满足，那么服务器就会执行BGSAVE命令。</p><p>以上就是Redis服务器根据save选项所设置的保存条件，自动执行BGSAVE命令，进行间隔性数据保存的实现原理。</p><h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>一个完整RDB文件所包含的各个部分如下</p><table><thead><tr><th>REDIS</th><th>db_version</th><th>databases</th><th>EOF</th><th>check_sum</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>全大写单词标示常量，全小写单词标示变量和数据。</p><p>RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。</p><p>db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如”0006”就代表RDB文件的版本为第六版。</p><p>databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据：</p><ul><li>如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。</li><li>如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。</li></ul><p>EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。</p><p>check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。</p><h4 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h4><p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p><p>例如，如果服务器的0号数据库和3号数据库非空，那么服务器创建一个如下表所示的RDB文件：</p><table><thead><tr><th>REDIS</th><th>db_version</th><th>databases0</th><th>databases3</th><th>EOF</th><th>check_sum</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分。</p><p>SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。</p><p>db_number保存着一个数据库号码。当程序读取db_number之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换。</p><p>key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。</p><p>例如，一个完整的RDB文件，文件中包含了0号数据库和3号数据库：</p><table><thead><tr><th>REDIS</th><th>db_version</th><th>SELECTDB</th><th>0</th><th>pairs</th><th>SELECTDB</th><th>3</th><th>pairs</th><th>EOF</th><th>check_sum</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h4><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对，如果键值对带有过期时间的话，那么键值对的过期时间也会被保存在内。不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成</p><p>TYPE记录了value的类型，长度为1字节，值可以是以下常量的其中一个：</p><ul><li><p>REDIS_RDB_TYPE_STRING</p></li><li><p>REDIS_RDB_TYPE_LIST</p></li><li><p>REDIS_RDB_TYPE_SET</p></li><li><p>REDIS_RDB_TYPE_ZSET</p></li><li><p>REDIS_RDB_TYPE_HASH</p></li><li><p>REDIS_RDB_TYPE_LIST_ZIPLIST</p></li><li><p>REDIS_RDB_TYPE_SET_INTSET</p></li><li><p>REDIS_RDB_TYPE_ZSET_ZIPLIST</p></li><li><p>REDIS_RDB_TYPE_HASH_ZIPLIST</p></li></ul><p>当服务器读入RDB文件中的键值对数据时，程序会根据TYPE的值来决定如何读入和解释value的数据。key和value分别保存了键值对的键对象和值对象：</p><ul><li>其中key总是一个字符串对象，它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样。根据内容长度的不同，key的长度也会有所不同。</li><li>根据TYPE类型的不同，以及保存内容长度的不同，保存value的结构和长度也会有所不同，本节稍后会详细说明每种TYPE类型的value结构保存方式。</li></ul><p>带有过期时间的键值对新增了EXPIRETIME_MS和ms，它们的意义如下：</p><ul><li>EXPIRETIME_MS常量的长度为1字节，以毫秒为单位。</li><li>ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。</li></ul><h4 id="value的编码"><a href="#value的编码" class="headerlink" title="value的编码"></a>value的编码</h4><p>RDB文件中的每个value部分都保存了一个值对象，每个值对象的类型都由与之对应的TYPE记录。</p><h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><p>TYPE &#x3D; REDIS_RDB_TYPE_STRING时，value保存的是一个字符串对象，字符串对象的编码可以是REDIS_ENCODING_INT或者REDIS_ENCODING_RAW。</p><p>如果字符串对象的编码为REDIS_ENCODING_INT，那么说明对象中保存的是长度不超过32位的整数。</p><table><thead><tr><th>ENCODING</th><th>integer</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>其中，ENCODING的值可以是REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16或者REDIS_RDB_ENC_INT32。</p><p>如果字符串对象的编码为REDIS_ENCODING_RAW，那么说明对象所保存的是一个字符串值，根据字符串长度的不同，有压缩和不压缩两种方法来保存这个字符串：</p><ul><li>如果字符串的长度小于等于20字节，那么这个字符串会直接被原样保存。</li><li>如果字符串的长度大于20字节，那么这个字符串会被压缩之后再保存。</li></ul><p>如果服务器关闭了RDB文件压缩功能，那么RDB程序总以无压缩的方式保存字符串值。具体信息可以参考redis.conf文件中关于rdbcompression选项的说明。</p><p>没有被压缩的字符串，结构如下：</p><table><thead><tr><th>len</th><th>string</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>string部分保存了字符串值本身，而len保存了字符串值的长度。</p><p>压缩后的字符串，结构如下：</p><table><thead><tr><th>REDIS_RDB_ENC_LZF</th><th>compressed_len</th><th>origin_len</th><th>compressed_string</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>REDIS_RDB_ENC_LZF常量: 字符串被LZF算法压缩，读入程序在碰到这个常量时，会根据之后的compressed_len、origin_len和compressed_string三部分，对字符串进行解压缩：</p><ul><li><p>compressed_len记录字符串被压缩之后的长度。</p></li><li><p>origin_len记录字符串原来的长度。</p></li><li><p>compressed_string记录被压缩之后的字符串。</p></li></ul><h5 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h5><p>TYPE &#x3D; REDIS_RDB_TYPE_LIST，value保存的是一个REDIS_ENCODING_LINKEDLIST编码的列表对象，结构如下：</p><table><thead><tr><th>list_length</th><th>item1</th><th>item2</th><th>…</th><th>itemN</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>list_length记录了列表的长度，它记录列表保存了多少个项（item），读入程序可以通过这个长度知道自己应该读入多少个列表项。</p><p>item:： length string</p><p>示例：</p><p>5 “world”</p><h5 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h5><p>TYPE &#x3D; REDIS_RDB_TYPE_SET，value保存的是一个REDIS_ENCODING_HT编码的集合对象，结构如下：</p><table><thead><tr><th>set_size</th><th>elem1</th><th>…</th><th>elemN</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>set_size是集合的大小，它记录集合保存了多少个元素，读入程序可以通过这个大小知道自己应该读入多少个集合元素。</p><h5 id="哈希表对象"><a href="#哈希表对象" class="headerlink" title="哈希表对象"></a>哈希表对象</h5><p>TYPE &#x3D; REDIS_RDB_TYPE_HASH，value保存的是一个REDIS_ENCODING_HT编码的集合对象，结构如下：</p><table><thead><tr><th>hash_size</th><th>k_v_pair1</th><th>k_v_pair2</th><th>…</th><th>k_v_pairN</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>hash_size记录了哈希表的大小，也即是这个哈希表保存了多少键值对，读入程序可以通过这个大小知道自己应该读入多少个键值对。</li><li>以key_value_pair开头的部分代表哈希表中的键值对，键值对的键和值都是字符串对象，所以程序会以处理字符串对象的方式来保存和读入键值对。</li></ul><p>结构中的每个键值对都以键紧挨着值的方式排列在一起，如下所示：</p><table><thead><tr><th>k1</th><th>v1</th><th>k2</th><th>v2</th><th>…</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>示例，下表展示了一个包含两个键值对的哈希表。</p><table><thead><tr><th>2</th><th>1</th><th>“a”</th><th>5</th><th>“apple”</th><th>1</th><th>“b”</th><th>6</th><th>“banana”</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第一个数字2记录了哈希表的键值对数量，之后跟着的是两个键值对：</p><ul><li>第一个键值对的键是长度为1的字符串”a”，值是长度为5的字符串”apple”。</li><li>第二个键值对的键是长度为1的字符串”b”，值是长度为6的字符串”banana”。</li></ul><h5 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h5><p>TYPE &#x3D; REDIS_RDB_TYPE_ZSET，value保存的是一个REDIS_ENCODING_SKIPLIST编码的有序集合对象，结构如下：</p><table><thead><tr><th>sorted_set_size</th><th>elem1</th><th>…</th><th>elemN</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>sorted_set_size记录了有序集合的大小，读入程序需要根据这个值来决定应该读入多少有序集合元素。</p><p>以element开头的部分代表有序集合中的元素，每个元素又分为成员（member）和分值（score）两部分，成员是一个字符串对象，分值则是一个double类型的浮点数，程序在保存RDB文件时会先将分值转换成字符串对象，然后再用保存字符串对象的方法将分值保存起来。</p><h5 id="INTSET编码的集合"><a href="#INTSET编码的集合" class="headerlink" title="INTSET编码的集合"></a>INTSET编码的集合</h5><p>TYPE &#x3D; REDIS_RDB_TYPE_SET_INTSET，value保存的是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。</p><p>如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的指示，先读入字符串对象，再将这个字符串对象转换成原来的整数集合对象。</p><h5 id="ZIPLIST编码的列表、哈希表或者有序集合"><a href="#ZIPLIST编码的列表、哈希表或者有序集合" class="headerlink" title="ZIPLIST编码的列表、哈希表或者有序集合"></a>ZIPLIST编码的列表、哈希表或者有序集合</h5><p>TYPE &#x3D; REDIS_RDB_TYPE_LIST_ZIPLIST、REDIS_RDB_TYPE_HASH_ZIPLIST或者REDIS_RDB_TYPE_ZSET_ZIPLIST，value保存的是一个压缩列表对象，RDB文件保存这种对象的方法是：</p><ol><li>将压缩列表转换成一个字符串对象。</li><li>将转换所得的字符串对象保存到RDB文件。</li></ol><p>如果程序在读入RDB文件的过程中，碰到由压缩列表对象转换成的字符串对象，那么程序会根据TYPE值的指示，执行以下操作：</p><ol><li>读入字符串对象，并将它转换成原来的压缩列表对象。</li><li>根据TYPE，设置压缩列表对象的类型：如果TYPE&#x3D;REDIS_RDB_TYPE_LIST_ZIPLIST，那么压缩列表对象的类型为列表；如果TYPE&#x3D;REDIS_RDB_TYPE_HASH_ZIPLIST，那么压缩列表对象的类型为哈希表；如果TYPE&#x3D;REDIS_RDB_TYPE_ZSET_ZIPLIST，那么压缩列表对象的类型为有序集合。</li></ol><p>由于TYPE的存在，即使列表、哈希表和有序集合三种类型都使用压缩列表来保存，RDB读入程序也总可以将读入并转换之后得出的压缩列表设置成原来的类型。</p><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul><li><p>RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。</p></li><li><p>SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</p></li><li><p>BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。</p></li><li><p>服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。</p></li><li><p>RDB文件是一个经过压缩的二进制文件，由多个部分组成。</p></li><li><p>对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 设计与实现(8-数据库)</title>
      <link href="/RoyalLiang.github.io/post/6b54b752.html"/>
      <url>/RoyalLiang.github.io/post/6b54b752.html</url>
      
        <content type="html"><![CDATA[<h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><p>Redis服务器将所有数据库都保存在服务器状态redis.h&#x2F;redisServer结构的db数组中，db数组的每个项都是一个redis.h&#x2F;redisDb结构，每个redisDb结构代表一个数据库：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">    //一个数组，保存着服务器中的所有数据库</span><br><span class="line">    redisDb *db;</span><br><span class="line">    //服务器的数据库数量</span><br><span class="line">    int dbnum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在初始化服务器时，程序会根据服务器状态的dbnum属性来决定应该创建多少个数据库。</p><p>dbnum属性的值由服务器配置的database选项决定，默认情况下，该选项的值为16。</p><h3 id="数据库切换"><a href="#数据库切换" class="headerlink" title="数据库切换"></a>数据库切换</h3><p>每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。</p><p>默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行<code>SELECT db</code>命令来切换目标数据库。</p><p>在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，这个属性是一个指向redisDb结构的指针：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct redisClient&#123;</span><br><span class="line">    //记录客户端当前正在使用的数据库</span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure><p>redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库。</p><p>通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是SELECT命令的实现原理。</p><h3 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h3><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个redis.h&#x2F;redisDb结构表示，其中，redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct redisDb&#123;</span><br><span class="line">    //数据库键空间，保存数据库中的所有键值对</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure><p>键空间和用户所见的数据库是直接对应的：</p><ul><li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li><li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li></ul><p><img src="https://cdn.notfound.icu/hexo/db1.png" alt="img"></p><p>因为数据库的键空间是一个字典，所以所有针对数据库的操作，比如添加一个键值对到数据库，或者从数据库中删除一个键值对，又或者在数据库中获取某个键值对等，实际上都是通过对键空间字典进行操作来实现的。</p><h4 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h4><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面。</p><p><img src="https://cdn.notfound.icu/hexo/db2.png" alt="img"></p><h4 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h4><p>删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</p><h4 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h4><p>对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值对象，根据值对象的类型不同，具体的取值方法也会有所不同。</p><p><img src="https://cdn.notfound.icu/hexo/db3.png" alt="img"></p><h4 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h4><p>除了上面列出的添加、删除、更新、取值操作之外，还有很多针对数据库本身的Redis命令，也是通过对键空间进行处理来完成的。</p><p>比如：</p><ul><li><p>用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。</p></li><li><p>用于随机返回数据库中某个键的RANDOMKEY命令，就是通过在键空间中随机返回一个键来实现的。</p></li><li><p>用于返回数据库键数量的DBSIZE命令，就是通过返回键空间中包含的键值对的数量来实现的。</p></li><li><p>类似的命令还有EXISTS、RENAME、KEYS等，这些命令都是通过对键空间进行操作来实现的。</p></li></ul><h4 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h4><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，其中包括：</p><ul><li><p>在读取一个键之后，服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</p></li><li><p>在读取一个键之后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime命令可以查看键key的闲置时间。</p></li><li><p>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</p></li><li><p>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</p></li><li><p>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</p></li><li><p>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</p></li></ul><h3 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h3><p>通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL）。</p><p>Redis有四个不同的命令可以用于设置键的生存时间（键可以存在多久）或过期时间（键什么时候会被删除）：</p><ul><li><p>EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒。</p></li><li><p>PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒。</p></li><li><p>EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。</p></li><li><p>PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。</p></li></ul><p>虽然有多种不同单位和不同形式的设置命令，但实际上EXPIRE、PEXPIRE、EXPIREAT三个命令都是使用PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一样。</p><p><img src="https://cdn.notfound.icu/hexo/db4.png" alt="img"></p><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典</p><ul><li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。</li><li>过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct redisDb&#123;</span><br><span class="line">    //过期字典，保存键的过期时间</span><br><span class="line">dict *expires;</span><br><span class="line">&#125;redisDb;</span><br></pre></td></tr></table></figure><p>当客户端执行PEXPIREAT命令（或者其他三个会转换成PEXPIREAT命令的命令）为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。</p><h4 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h4><p>PERSIST key 命令可以移除一个键 key 的过期时间。</p><h4 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h4><p>TTL key 命令以秒为单位返回键 key 的剩余生存时间，而 PTTL key 命令则以毫秒为单位返回键 key 的剩余生存时间。</p><h4 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h4><p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期：</p><ol><li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</li><li>检查当前UNIX时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</li></ol><p>实现过期键判定的另一种方法是使用TTL命令或者PTTL命令。在实际中，Redis检查键是否过期是直接访问过期字典。</p><h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。</p><p>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。</p><p>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p><p>这三种策略中，第一种和第三种为主动删除策略，而第二种则为被动删除策略。</p><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><p>定时删除策略对内存是最友好的，对CPU时间是最不友好的。</p><p>创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>惰性删除策略对CPU时间来说是最友好的，对内存是最不友好的。大量的过期数据积压将会造成类似“内存泄露”的情况。</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>定期删除策略是前两种策略的一种整合和折中：</p><ul><li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li><li>除此之外，通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费。</li></ul><p>定期删除策略的难点是确定删除操作执行的时长和频率：</p><ul><li>如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。</li><li>如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除策略一样，出现浪费内存的情况。</li></ul><h3 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h3><p>Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。</p><h4 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h4><p>过期键的惰性删除策略由db.c&#x2F;expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeeded函数对输入键进行检查：</p><ul><li>如果输入键已经过期，那么expireIfNeeded函数将输入键从数据库中删除。</li><li>如果输入键未过期，那么expireIfNeeded函数不做动作。</li></ul><p>每个命令的实现函数都必须能同时处理键存在以及键不存在这两种情况：</p><ul><li>当键存在时，命令按照键存在的情况执行。</li><li>当键不存在或者键因过期而被删除时，命令按照键不存在的情况执行。</li></ul><h4 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h4><p>过期键的定期删除策略由redis.c&#x2F;activeExpireCycle函数实现，每当Redis的服务器周期性操作redis.c&#x2F;serverCron函数执行时，activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。</p><p>activeExpireCycle函数的工作模式可以总结如下：</p><ul><li><p>函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</p></li><li><p>全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。</p></li><li><p>随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。</p></li></ul><h3 id="AOF、RDB和复制功能对过期键的处理"><a href="#AOF、RDB和复制功能对过期键的处理" class="headerlink" title="AOF、RDB和复制功能对过期键的处理"></a>AOF、RDB和复制功能对过期键的处理</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。</p><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对RDB文件进行载入：</p><ul><li>如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。</li><li>如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>当服务器以AOF持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么AOF文件不会因为这个过期键而产生任何影响。</p><p>当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。</p><p>和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><p>当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制：</p><ul><li><p>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</p></li><li><p>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除。</p></li><li><p>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</p></li></ul><p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性。</p><h3 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h3><p>客户端可以通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。</p><p>键空间通知（key-space notification）：“某个键执行了什么命令”的通知。</p><p>键事件通知（key-event notification）：“某个命令被什么键执行了”。</p><p>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：</p><ul><li><p>想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE。</p></li><li><p>想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK。</p></li><li><p>想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE。</p></li><li><p>想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$。</p></li><li><p>想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El。</p></li></ul><h4 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h4><p>发送数据库通知的功能是由notify.c&#x2F;notifyKeyspaceEvent函数实现的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void notifyKeyspaceEvent(int type, *event, robj, int dbid);</span><br></pre></td></tr></table></figure><p>函数的type参数是当前想要发送的通知的类型，程序会根据这个值来判断通知是否就是服务器配置notify-keyspace-events选项所选定的通知类型，从而决定是否发送通知。</p><p>event、keys和dbid分别是事件的名称、产生事件的键，以及产生事件的数据库号码，函数会根据type参数以及这三个参数来构建事件通知的内容，以及接收通知的频道名。</p><p>每当一个Redis命令需要发送数据库通知的时候，该命令的实现函数就会调用notify-KeyspaceEvent函数，并向函数传递传递该命令所引发的事件的相关信息。</p><h4 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h4><p>下图是notifyKeyspaceEvent函数的伪代码实现：</p><p><img src="https://cdn.notfound.icu/hexo/db5.png" alt="img"></p><ol><li><p>server.notify_keyspace_events属性就是服务器配置notify-keyspace-events选项所设置的值，如果给定的通知类型type不是服务器允许发送的通知类型，那么函数会直接返回，不做任何动作。</p></li><li><p>如果给定的通知是服务器允许发送的通知，那么下一步函数会检测服务器是否允许发送键空间通知，如果允许的话，程序就会构建并发送事件通知。</p></li><li><p>最后，函数检测服务器是否允许发送键事件通知，如果允许的话，程序就会构建并发送事件通知。</p></li></ol><p>另外，pubsubPublishMessage函数是PUBLISH命令的实现函数，执行这个函数等同于执行PUBLISH命令。</p><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><ul><li><p>Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。</p></li><li><p>客户端通过修改目标数据库指针，让它指向redisServer.db数组中的不同元素来切换不同的数据库。</p></li><li><p>数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。</p></li><li><p>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</p></li><li><p>数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。</p></li><li><p>expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。</p></li><li><p>Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。</p></li><li><p>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。</p></li><li><p>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。</p></li><li><p>当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。</p></li><li><p>当主服务器删除一个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。</p></li><li><p>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</p></li><li><p>当Redis命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 设计与实现(7-对象)</title>
      <link href="/RoyalLiang.github.io/post/d1a2b653.html"/>
      <url>/RoyalLiang.github.io/post/d1a2b653.html</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>Redis并没有直接使用SDS、链表、字典、跳跃表、整数集合、压缩列表等这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种前面的数据结构。</p><ul><li><p>Redis在执行命令前，可以根据对象的类型来判断一个对象是否可以执行给定的命令。</p></li><li><p>针对不同场景，为对象设置多种不同的数据结构实现，优化使用效率。</p></li><li><p>Redis对象系统实现了基于引用计数技术的内存回收机制。</p></li><li><p>通过引用计数技术实现了对象共享机制。</p></li><li><p>Redis的对象带有访问时间记录信息，用以过期清除。</p></li></ul><h3 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h3><p>每次在Redis的数据库中新创建一个键值对时，至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。</p><p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    //类型</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    //编码</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    //指向底层实现数据结构的指针</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>对象的type属性记录了对象的类型，这个属性的值可以是下表列出的常量的其中一个。</p><table><thead><tr><th>类型常量</th><th>对象名称</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>字符串对象</td></tr><tr><td>REDIS_LIST</td><td>列表对象</td></tr><tr><td>REDIS_HASH</td><td>哈希对象</td></tr><tr><td>REDIS_SET</td><td>集合对象</td></tr><tr><td>REDIS_ZSET</td><td>有序集合对象</td></tr></tbody></table><p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种，因此：</p><ul><li>当我们称呼一个数据库键为“字符串键”时，我们指的是“这个数据库键所对应的值为字符串对象”；</li><li>当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</li></ul><h4 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h4><p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现，这个属性的值可以是下表列出的常量的其中一个。</p><table><thead><tr><th>编码常量</th><th>所对应的数据结构</th></tr></thead><tbody><tr><td>REDIS_ENCODING_INT</td><td>long类型的整数</td></tr><tr><td>REDIS_ENCODING_EMBSTR</td><td>embstr编码的简单动态字符串</td></tr><tr><td>REDIS_ENCODING_RAW</td><td>简单动态字符串</td></tr><tr><td>REDIS_ENCODING_HT</td><td>字典</td></tr><tr><td>REDIS_ENCODING_LINKEDLIST</td><td>双短链表</td></tr><tr><td>REDIS_ENCODING_ZIPLIST</td><td>压缩表</td></tr><tr><td>REDIS_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>REDIS_ENCODING_SKIPLIST</td><td>跳跃表</td></tr></tbody></table><p>下表列出了每种类型的对象可以使用的编码。</p><table><thead><tr><th>类型</th><th>编码</th><th>对象</th></tr></thead><tbody><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_INT</td><td>使用整数值实现的字符串对象</td></tr><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_EMBSTR</td><td>使用embstr编码的简单动态字符串实现的字符串对象</td></tr><tr><td>REDIS_STRING</td><td>REDIS_ENCODING_RAW</td><td>使用简单动态字符串实现的字符串对象</td></tr><tr><td>REDIS_LIST</td><td>REDIS_ENCODING_ZIPLIST</td><td>压缩列表的list对象</td></tr><tr><td>REDIS_LIST</td><td>REDIS_ENCODING_LINKEDLIST</td><td>双端列表的list对象</td></tr><tr><td>REDIS_HASH</td><td>REDIS_ENCODING_ZIPLIST</td><td>压缩列表的哈希对象</td></tr><tr><td>REDIS_HASH</td><td>REDIS_ENCODING_HT</td><td>字典的哈希对象</td></tr><tr><td>REDIS_SET</td><td>REDIS_ENCODING_INTSET</td><td>整数集合的集合对象</td></tr><tr><td>REDIS_SET</td><td>REDIS_ENCODING_HT</td><td>字典的集合对象</td></tr><tr><td>REDIS_ZSET</td><td>REDIS_ENCODING_ZIPLIST</td><td>压缩列表的zset对象</td></tr><tr><td>REDIS_ZSET</td><td>REDIS_ENCODING_SKIPLIST</td><td>跳跃表的zset对象</td></tr></tbody></table><p>注：使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码。</p><p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>字符串对象的编码可以是int、raw或者embstr。</p><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构的ptr属性里面（将void*转换成long），并将字符串对象的编码设置为int。</p><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw。</p><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码和raw编码一样，都使用redisObject结构和sdshdr结构来表示字符串对象，但raw编码会调用两次内存分配函数来分别创建redisObject结构和sdshdr结构，而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构，如下所示：</p><p>embstr编码的字符串对象在执行命令时，产生的效果和raw编码的字符串对象执行命令时产生的效果是相同的，但使用embstr编码的字符串对象来保存短字符串值有以下好处：</p><ul><li><p>embstr编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</p></li><li><p>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</p></li><li><p>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。</p></li></ul><p>字符串对象保存各类型值的编码方式如下所示：</p><table><thead><tr><th>值</th><th>编码</th></tr></thead><tbody><tr><td>可以用long类型保存的整数</td><td>int</td></tr><tr><td>可以用long double类型保存的浮点数</td><td>embstr&#x2F;raw</td></tr><tr><td>字符串值或者因长度太大无法用long的整数，又或因长度太大无法用long double类型保存的浮点数</td><td>embstr&#x2F;raw</td></tr></tbody></table><p>因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），所以embstr编码的字符串对象实际上是只读的。</p><h4 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h4><p><img src="https://cdn.notfound.icu/hexo/obj1.png" alt="img"></p><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以是ziplist或者linkedlist。</p><p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素。</p><p>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p><p>ziplist编码的列表对象:</p><p><img src="https://cdn.notfound.icu/hexo/obj2.png" alt="img"></p><p>linkedlist编码的列表对象:</p><p><img src="https://cdn.notfound.icu/hexo/obj3.png" alt="img"></p><p>注意，linkedlist编码的列表对象在底层的双端链表结构中包含了多个字符串对象，字符串对象是Redis五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p><p><strong>注意，上面的图中，StringObject下的字符串three只是简化字符串对象的表示。完整的写法是three存储在buf数组中。</strong></p><h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节；</li><li>列表对象保存的元素数量小于512个；</li></ul><p>不能满足这两个条件的列表对象需要使用linkedlist编码。</p><p>以上两个条件的上限值是可以修改的，具体查看配置文件中关于list-max-ziplist-value选项和list-max-ziplist-entries选项的说明。</p><p>对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面，对象的编码也会从ziplist变为linkedlist。</p><h4 id="列表命令实现"><a href="#列表命令实现" class="headerlink" title="列表命令实现"></a>列表命令实现</h4><p><img src="https://cdn.notfound.icu/hexo/obj4.png" alt="img"></p><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是ziplist或者hashtable。</p><p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p><ul><li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后；</li><li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li></ul><p>hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p><ul><li>字典的每个键都是一个字符串对象，对象中保存了键值对的键；</li><li>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</li></ul><p>eg：</p><p><img src="https://cdn.notfound.icu/hexo/obj5.png" alt="img"><img src="https://cdn.notfound.icu/hexo/obj6.png" alt="img"></p><h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p><ul><li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li><li>哈希对象保存的键值对数量小于512个；</li></ul><p>不能满足这两个条件的哈希对象需要使用hashtable编码。</p><p>两个条件的上限值是可以修改的，具体查看配置文件中关于hash-max-ziplist-value选项和hash-max-ziplist-entries选项的说明。</p><p>对于使用ziplist编码的列表对象来说，当使用ziplist编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行。</p><h4 id="哈希命令的实现"><a href="#哈希命令的实现" class="headerlink" title="哈希命令的实现"></a>哈希命令的实现</h4><p><img src="https://cdn.notfound.icu/hexo/obj7.png" alt="img"></p><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是intset或者hashtable。</p><p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p><p>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL。</p><p>eg：</p><p><img src="https://cdn.notfound.icu/hexo/obj8.png" alt="img"></p><h4 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h4><p>当集合对象可以同时满足以下两个条件时，对象使用intset编码：</p><ul><li>集合对象保存的所有元素都是整数值；</li><li>集合对象保存的元素数量不超过512个。</li></ul><p>不能满足这两个条件的集合对象需要使用hashtable编码。</p><p>第二个条件的上限值是可以修改的，具体查看配置文件中关于set-max-intset-entries选项的说明。</p><p>对于使用intset编码的集合对象来说，当使用intset编码所需的两个条件的任意一个不能被满足时，就会执行对象的编码转换操作。</p><h4 id="集合命令的实现"><a href="#集合命令的实现" class="headerlink" title="集合命令的实现"></a>集合命令的实现</h4><p><img src="https://cdn.notfound.icu/hexo/obj9.png" alt="img"></p><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合的编码可以是ziplist或者skiplist。</p><p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。</p><p>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</p><p>eg：</p><p><img src="https://cdn.notfound.icu/hexo/obj10.png" alt="img"></p><p><img src="https://cdn.notfound.icu/hexo/obj11.png" alt="img"></p><p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct zset&#123;</span><br><span class="line">zskiplist *zsl;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>zset结构中的zsl跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的object属性保存了元素的成员，而跳跃表节点的score属性则保存了元素的分值。通过这个跳跃表，程序可以对有序集合进行范围型操作，比如ZRANK、ZRANGE等命令就是基于跳跃表API来实现的。</p><p>zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。</p><h4 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h4><p>当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：</p><ul><li>有序集合保存的元素数量小于128个；</li><li>有序集合保存的所有元素成员的长度都小于64字节；</li></ul><p>不能满足以上两个条件的有序集合对象将使用skiplist编码。</p><p>以上两个条件的上限值是可以修改的，具体查看配置文件中关于zset-max-ziplist-entries选项和zset-max-ziplist-value选项的说明。</p><h4 id="有序集合命令的实现"><a href="#有序集合命令的实现" class="headerlink" title="有序集合命令的实现"></a>有序集合命令的实现</h4><p><img src="https://cdn.notfound.icu/hexo/obj12.png" alt="img"></p><h3 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h3><p>Redis中用于操作键的命令基本上可以分为两种类型。</p><p>其中一种命令可以对任何类型的键执行，比如说DEL命令、EXPIRE命令、RENAME命令、TYPE命令、OBJECT命令等。</p><p>而另一种命令只能对特定类型的键执行，比如说：</p><ul><li><p>SET、GET、APPEND、STRLEN等命令只能对字符串键执行；</p></li><li><p>HDEL、HSET、HGET、HLEN等命令只能对哈希键执行；</p></li><li><p>RPUSH、LPOP、LINSERT、LLEN等命令只能对列表键执行；</p></li><li><p>SADD、SPOP、SINTER、SCARD等命令只能对集合键执行；</p></li><li><p>ZADD、ZCARD、ZRANK、ZSCORE等命令只能对有序集合键执行；</p></li></ul><h4 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h4><p>类型特定命令所进行的类型检查是通过redisObject结构的type属性来实现的：</p><ul><li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；</li><li>否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</li></ul><h4 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h4><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p><p><img src="https://cdn.notfound.icu/hexo/obj13.png" alt="img"></p><h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>Redis在自己的对象系统中构建了一个引用计数（reference counting）技术实现了内存回收机制。通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p><p>每个对象的引用计数信息由redisObject结构的refcount属性记录：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    //引用计数</span><br><span class="line">    int refcount;</span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><p>对象的引用计数信息会随着对象的使用状态而不断变化：</p><ul><li><p>在创建一个新对象时，引用计数的值会被初始化为1；</p></li><li><p>当对象被一个新程序使用时，它的引用计数值会被增一；</p></li><li><p>当对象不再被一个程序使用时，它的引用计数值会被减一；</p></li><li><p>当对象的引用计数值变为0时，对象所占用的内存会被释放。</p></li></ul><p>修改对象引用计数的API如下表:</p><p><img src="https://cdn.notfound.icu/hexo/obj14.png" alt="img"></p><h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</p><p>在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：</p><ol><li>将数据库键的值指针指向一个现有的值对象；</li><li>将被共享的值对象的引用计数增一。</li></ol><p>创建共享字符串对象的数量可以通过修改redis.h&#x2F;REDIS_SHARED_INTEGERS常量来修改。</p><p>使用OBJECT REFCOUNT key命令查看键key的值对象的引用计数</p><p>为什么Redis不共享包含字符串的对象？</p><p>一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多。</p><h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p>除了type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line">    //</span><br><span class="line">    unsigned lru:22;</span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure><p>OBJECT IDLETIME key 命令可以打印出 key 的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的。</p><p>OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。</p><p>除了可以被OBJECT IDLETIME命令打印出来之外，键的空转时长还有另外一项作用：如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p><p>配置文件的maxmemory选项和maxmemory-policy选项的说明介绍了关于这方面的更多信息。</p><h3 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h3><p>Redis数据库中的每个键值对的键和值都是一个对象。</p><p>Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</p><p>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</p><p>Redis的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放。</p><p>Redis会共享值为0到9999的字符串对象。</p><p>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</p>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 设计与实现(6-压缩列表)</title>
      <link href="/RoyalLiang.github.io/post/23dbd94d.html"/>
      <url>/RoyalLiang.github.io/post/23dbd94d.html</url>
      
        <content type="html"><![CDATA[<p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项&#x2F;当一个哈希键只包含少量键值对，并且每个列表项&#x2F;每个键值对的键和值 要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><h3 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h3><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p><p>压缩列表组成部分说明：</p><table><thead><tr><th></th><th>类型</th><th>长度</th><th>用途</th></tr></thead><tbody><tr><td>zlbytes</td><td>uint_32</td><td>4</td><td>记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配或计算zlen的位置时使用。</td></tr><tr><td>zltail</td><td>uint_32</td><td>4</td><td>记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无需遍历整个压缩列表就可以确定表尾节点的地址。</td></tr><tr><td>zllen</td><td>uint_16</td><td>2</td><td>记录了压缩列表包含的节点数量：当这个属性的值小于uint16_max(65535)时，这个属性的值就是压缩列表包含节点的数量uint16_max；当这个值等于，节点的真实数量需要遍历整个压缩列表才能计算出</td></tr><tr><td>entry1-N</td><td>列表节点</td><td>不定</td><td>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td>zlend</td><td>uint_8</td><td>1</td><td>特殊值0xFF(255)，用于标记压缩列表的末端。</td></tr></tbody></table><h3 id="节点的构成"><a href="#节点的构成" class="headerlink" title="节点的构成"></a>节点的构成</h3><p>每个压缩列表节点可以保存一个字节数组或者一个整数值，其中，字节数组可以是以下三种长度的其中一种：</p><ul><li><p>长度小于等于63（2**6–1）字节的字节数组；</p></li><li><p>长度小于等于16383（2**14–1）字节的字节数组；</p></li><li><p>长度小于等于4294967295（2**32–1）字节的字节数组；</p></li></ul><p>而整数值则可以是以下六种长度的其中一种：</p><ul><li><p>4位长，介于0至12之间的无符号整数；</p></li><li><p>1&#x2F;3 字节长的有符号整数；</p></li><li><p>int16_t&#x2F;int32_t&#x2F;int64_t 类型整数</p></li></ul><p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成</p><h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。属性的长度可以是1字节或者5字节。</p><ul><li>如果前一节点的长度小于254字节，那么previous_entry_length属性的长度为1字节：前一节点的长度就保存在这一个字节里面。</li><li>如果前一节点的长度大于等于254字节，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置为0xFE（十进制值254），而之后的四个字节则用于保存前一节点的长度。</li></ul><p>eg：</p><p>previous_entry_length &#x3D; 0xFE00002766，值的最高位字节0xFE表示这是一个五字节长的previous_entry_length属性，而之后的四字节0x00002766（十进制值10086）才是前一节点的实际长度。</p><p>由此特性，程序可以通过指针运算，根据当前节点的起始地址来计算出前一个节点的起始地址。</p><p>压缩列表的从表尾向表头遍历操作也是使用这一原理实现的。</p><h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>encoding属性记录了节点的content属性所保存数据的类型以及长度。</p><ul><li>一字节、两字节或者五字节长，值的最高位为00、01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；</li><li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录；</li></ul><p>字节数组编码：</p><table><thead><tr><th>编码</th><th>编码长度（byte）</th><th>content属性保存的值</th></tr></thead><tbody><tr><td>00bbbbbb</td><td>1</td><td>长度小于等于63字节的字节数组</td></tr><tr><td>01bbbbbb xxxxxxxx</td><td>2</td><td>长度小于等于16383字节的字节数组</td></tr><tr><td>10___*_* aaaaaaaa bbbbbbbb cccccccc dddddddd</td><td>5</td><td>长度小于等于4294967295字节的字节数组</td></tr></tbody></table><p>整数编码：</p><table><thead><tr><th>编码</th><th>编码长度(byte)</th><th>content属性保存的值</th></tr></thead><tbody><tr><td>11000000</td><td>1</td><td>int16_t类型的整数</td></tr><tr><td>11010000</td><td>1</td><td>int32_t类型的整数</td></tr><tr><td>11100000</td><td>1</td><td>int64_t类型的整数</td></tr><tr><td>11110000</td><td>1</td><td>24位有符号数</td></tr><tr><td>11111110</td><td>1</td><td>8位有符号数</td></tr><tr><td>xxxxxxxx</td><td>1</td><td>使用该编码的节点没有content属性，因为xxxx四位本身就保存了一个介于0到12之间的值</td></tr></tbody></table><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。</p><h3 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h3><p>Redis将在特殊情况下产生的连续多次空间扩展&#x2F;收缩操作称之为“连锁更新”。除了添加新节点可能会引发连锁更新之外，删除节点也可能会引发连锁更新。</p><p>eg：</p><p>在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的节点e1至eN。</p><p>e1至eN的所有节点的长度都小于254字节，所以记录这些节点的previous_entry_length属性都是1字节长的。</p><p>这时，如果我们将一个长度大于等于254字节的新节点new设置为压缩列表的表头节点，那么new将成为e1的前置节点。</p><p>因为e1的previous_entry_length属性仅长1字节，它没办法保存新节点new的长度，所以程序将对压缩列表执行空间重分配操作，并将e1节点的previous_entry_length属性从原来的1字节长扩展为5字节长。</p><p>现在，麻烦的事情来了，e1原本的长度介于250字节至253字节之间，在为previous_entry_length属性新增四个字节的空间之后，e1的长度就变成了介于254字节至257字节之间，而这种长度使用1字节长的previous_entry_length属性是没办法保存的。</p><p>因此，为了让e2的previous_entry_length属性可以记录下e1的长度，程序需要再次对压缩列表执行空间重分配操作，并将e2节点的previous_entry_length属性从原来的1字节长扩展为5字节长。</p><p>配图如下：</p><p><img src="https://cdn.notfound.icu/hexo/yasuo.png" alt="img"></p><p>要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的：</p><ul><li>首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点，连锁更新才有可能被引发；</li><li>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响；</li></ul><p>因为以上原因，ziplistPush等命令的平均复杂度仅为O（N）</p><h3 id="压缩列表API"><a href="#压缩列表API" class="headerlink" title="压缩列表API"></a>压缩列表API</h3><p>因为ziplistPush、ziplistInsert、ziplistDelete和ziplistDeleteRange四个函数都有可能会引发连锁更新，所以它们的最坏复杂度都是O（N**2）。</p><h3 id="压缩列表总结"><a href="#压缩列表总结" class="headerlink" title="压缩列表总结"></a>压缩列表总结</h3><p>压缩列表是一种为节约内存而开发的顺序型数据结构。</p><p>压缩列表被用作列表键和哈希键的底层实现之一。</p><p>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</p><p>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率并不高。</p>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现(5-整数集合)</title>
      <link href="/RoyalLiang.github.io/post/48e3361d.html"/>
      <url>/RoyalLiang.github.io/post/48e3361d.html</url>
      
        <content type="html"><![CDATA[<p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。</p><h3 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h3><p>整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p><p>每个intset.h&#x2F;intset结构表示一个整数集合：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct intset&#123;</span><br><span class="line">    //编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    //集合包含元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line">    //保存元素的数组</span><br><span class="line">    int8_t contents[]</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><blockquote><p>contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。</p><p>length属性记录了整数集合包含的元素数量，即contents数组的长度。</p><p>虽然intset结构将contents属性声明为int8_t类型的数组，但contents数组的真正类型取决于encoding属性的值。</p></blockquote><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>当我们将一个新元素添加到整数集合里面时，如果新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。</p><p>升级整数集合并添加新元素共分为三步进行：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li><li>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。</li><li>将新元素添加到底层数组里面。</li></ol><p>由于每次向整数集合添加新元素都可能会引起升级，而每次升级都需要对底层数组中已有的所有元素进行类型转换，所以向整数集合添加新元素的时间复杂度为O（N）。同事，因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有元素，要么就小于所有现有元素。</p><h4 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h4><ul><li>提升灵活性</li></ul><p>因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面。</p><ul><li>节约内存</li></ul><p>升级操作只会在有需要的时候进行，这可以尽量节省内存。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h3 id="整数集合总结"><a href="#整数集合总结" class="headerlink" title="整数集合总结"></a>整数集合总结</h3><blockquote><p>整数集合是集合键的底层实现之一。</p><p>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。</p><p>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。</p><p>整数集合只支持升级操作，不支持降级操作。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现(4-跳跃表)</title>
      <link href="/RoyalLiang.github.io/post/661ae741.html"/>
      <url>/RoyalLiang.github.io/post/661ae741.html</url>
      
        <content type="html"><![CDATA[<p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><blockquote><p>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p></blockquote><p>Redis使用跳跃表作为有序集合键的底层实现之一：</p><ul><li>有序集合包含的元素数量比较多。</li><li>有序集合中元素的成员（member）是比较长的字符串。</li></ul><p>Redis只在两个地方用到了跳跃表：</p><ol><li>实现有序集合键。</li><li>在集群节点中用作内部数据结构。</li></ol><h3 id="跳跃表实现"><a href="#跳跃表实现" class="headerlink" title="跳跃表实现"></a>跳跃表实现</h3><p>Redis的跳跃表由 redis.h&#x2F;zskiplistNode 和 redis.h&#x2F;zskiplist 两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息。</p><h4 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h4><p>跳跃表节点的实现由redis.h&#x2F;zskiplistNode结构定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct zskiplistNode&#123;</span><br><span class="line">    //层</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        //前进指针</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        //跨度</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    //后退指针</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    //分值</span><br><span class="line">    double score;</span><br><span class="line">    成员对象</span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><ul><li>层</li></ul><blockquote><p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。一般来说，层的数量越多，访问其他节点的速度就越快。</p><p>每次创建一个新跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。</p></blockquote><p><img src="https://cdn.notfound.icu/hexo/skiptable1.png"></p><p>上图为不同层高节点</p><ul><li>前进指针</li></ul><blockquote><p>每个层都有一个指向表尾方向的前进指针（level[i].forward属性），用于从表头向表尾方向访问节点。</p></blockquote><p><img src="https://cdn.notfound.icu/hexo/skiptable2.png"></p><p>上图用虚线表示出了程序从表头向表尾方向，遍历跳跃表中所有节点的路径</p><ul><li>跨度</li></ul><blockquote><p>层的跨度（level[i].span属性）用于记录两个节点之间的距离。</p><ul><li>两个节点之间的跨度越大，它们相距得就越远。</li><li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点。</li></ul><p>跨度是用来计算排位（rank）的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</p></blockquote><ul><li>后退指针</li></ul><blockquote><p>后退指针用于从表尾向表头方向访问节点，跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</p></blockquote><ul><li>分值和成员</li></ul><blockquote><p>节点的分值是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序。</p><p>节点的成员对象是一个指针，它指向一个字符串对象，而字符串对象则保存着一个SDS值。</p><p>在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的。</p><p>分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p></blockquote><h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>仅靠多个跳跃表节点就可以组成一个跳跃表，但通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量等信息。</p><p>zskiplist结构的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct zskiplist&#123;</span><br><span class="line">    //表头节点和表尾节点</span><br><span class="line">    struct zskiplistNode *head, *tail;</span><br><span class="line">    //表中节点数量</span><br><span class="line">    unsigned int length;</span><br><span class="line">    //表中层数最大的节点的层数</span><br><span class="line">    int level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><blockquote><p>表头节点不计算在内。</p></blockquote><h3 id="跳跃表API"><a href="#跳跃表API" class="headerlink" title="跳跃表API"></a>跳跃表API</h3><h3 id="跳跃表总结"><a href="#跳跃表总结" class="headerlink" title="跳跃表总结"></a>跳跃表总结</h3><blockquote><ul><li>跳跃表是有序集合的底层实现之一。</li><li>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是1至32之间的随机数。</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象字典序的大小进行排序。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划问题思维导图</title>
      <link href="/RoyalLiang.github.io/post/20af7554.html"/>
      <url>/RoyalLiang.github.io/post/20af7554.html</url>
      
        <content type="html"><![CDATA[<p>附图一张<br><img src="https://cdn.notfound.icu/hexo/dongtai.png"></p>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 设计与实现(3-字典)</title>
      <link href="/RoyalLiang.github.io/post/f57febb8.html"/>
      <url>/RoyalLiang.github.io/post/f57febb8.html</url>
      
        <content type="html"><![CDATA[<p>字典：用于保存键值对（key-value pair）的抽象数据结构。</p><p>字典是Redis的数据库的底层实现，也是哈希的底层实现之一，但由于C语言没有字典这一数据结构，所以Redis自己构建了该数据结构。</p><h3 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h3><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h4 id="Redis的哈希表实现"><a href="#Redis的哈希表实现" class="headerlink" title="Redis的哈希表实现"></a>Redis的哈希表实现</h4><p>Redis字典所使用的哈希表由dict.h&#x2F;dictht结构定义：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct dictht&#123;</span><br><span class="line">    //哈希表数组</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    //哈希表大小</span><br><span class="line">    unsigned long size;</span><br><span class="line">    //哈希表大小掩码。用于计算索引值，总是等于size - 1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    //哈希表已有节点的数量</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><blockquote><p>table属性是一个数组，数组中的每个元素都是一个指向dict.h&#x2F;dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。</p></blockquote><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">    //键</span><br><span class="line">    void *key;</span><br><span class="line">    //值</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    //指向下一个哈希表节点，形成链表</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><blockquote><p>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。</p><p>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题。</p></blockquote><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>Redis中的字典由dict.h&#x2F;dict结构表示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">    //类型特定函数</span><br><span class="line">    dictType *type;</span><br><span class="line">    //私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line">    //哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    //rehash索引，当rehash不在进行时，值 == -1</span><br><span class="line">    int trehashidx;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p><blockquote><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p><p>privdata属性保存了需要传给那些类型特定函数的可选参数。</p><p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</p><p>rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1。</p></blockquote><p>dictType结构体定义如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct dictType&#123;</span><br><span class="line">    //计算哈希值的函数</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line">    //复制键的函数</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line">    //复制值的函数</span><br><span class="line">    void *(*valDup)(void *privdata, const void *key);</span><br><span class="line">    //对比键的函数</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line">    //销毁键的函数</span><br><span class="line">    void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line">    //销毁值的函数</span><br><span class="line">    void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>（未完，待补充～）</p><p>下图是一个未进行rehash的普通字典案例：</p><p><img src="https://cdn.notfound.icu/hexo/lianbiao-rehash.png"></p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><p><strong>当字典被用作数据库的底层实现，或者哈希键的底层实现时，****Redis使用MurmurHash2算法来计算键的哈希值。</strong></p><blockquote><p>MurmurHash算法最初由Austin Appleby于2008年发明，这种算法的优点在于，即使输入的键是有规律的，算法仍能给出一个很好的随机分布性，并且算法的计算速度也非常快。</p></blockquote><p>对于新添加到字典的键值对来说，程序首先需要根据键进行哈希计算，计算出其哈希值与索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上。</p><p>Redis计算哈希值与索引值的方法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用字典设置的哈希函数，计算键的哈希值</span><br><span class="line">hash = dict -&gt; type -&gt; hashFunction(key);</span><br><span class="line">//使用哈希表的sizemask属性和哈希值，计算索引，根据不同情况，ht[x]可以是ht[0]或ht[1]</span><br><span class="line">idx = hash &amp; dict[x].sizemask</span><br></pre></td></tr></table></figure><p>eg：将 k0 与 v0 添加到字典</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1. 计算哈希</span><br><span class="line">hash = dict -&gt; type -&gt; hashFunction(k0);</span><br><span class="line">//2. 计算索引，设k0=8，dict -&gt; table 的 size为4</span><br><span class="line">idx = 8 &amp; ht[0].sizemask = 8 &amp; 3 = 0;</span><br><span class="line">//放置新的键值对</span><br><span class="line">//根据idx的值，新的键值对将会放在table数组的第一位</span><br></pre></td></tr></table></figure><p>示例图如下：</p><p><img src="https://cdn.notfound.icu/hexo/lianbiao-ex.png"></p><h3 id="键冲突"><a href="#键冲突" class="headerlink" title="键冲突"></a>键冲突</h3><p>当哈希表数组同一索引上的键等于或超过 2 以上时，就会产生键冲突，而<strong>Redis的哈希表通过链地址法来解决冲突。</strong></p><p>链地址法：</p><blockquote><p>每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，以此解决键冲突的问题。</p><p>由于 dictEntry 节点组成的链表没有指向链表表尾的指针。为了速度考虑，程序总是将新节点添加到链表的表头位置。</p></blockquote><h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>随着操作的不断执行，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>Redis对字典的哈希表执行rehash的步骤如下：</p><ol><li>为字典ht[1]哈希表分配空间，空间大小取决于执行的操作，以及ht[0]当前的键值对数量（used属性的值）。</li></ol><ul><li>扩充操作：ht[1].size 等于第一个大于等于 ht[0].used * 2 的 2n</li><li>缩减操作：ht[1].size 等于第一个大于等于 ht[0].used 的 2n</li></ul><ol><li>将保存在ht[0]中的所有键值对rehash到ht[1]上，reshash指的是重新计算键的哈希值与索引值。</li><li>当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</li></ol><h3 id="扩容-x2F-收缩条件"><a href="#扩容-x2F-收缩条件" class="headerlink" title="扩容&#x2F;收缩条件"></a>扩容&#x2F;收缩条件</h3><p>当出现一下任意情况时，哈希表会自动扩容</p><blockquote></blockquote><ul><li>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。</li><li>服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。</li></ul><p><code>负载因子</code>的计算如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 负载因子 = 哈希表已使用节点数 / 哈希表大小</span><br><span class="line">load_factory = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure><p>根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制（copy-on-write）技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p><p>备注：</p><blockquote><p>当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p></blockquote><h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。</p><p>哈希表渐进式rehash的详细步骤如下：</p><ol><li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</li><li>在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</li><li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值加 1。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。</li></ol><blockquote><p>在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。</p><p>在渐进式rehash执行期间，新添加到字典的键值对一律会保存到ht[1]里面，ht[0]则不再进行任何添加操作，保证ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。</p></blockquote><h3 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h3><table><thead><tr><th>函数</th><th>功能</th><th>时间复杂度</th></tr></thead><tbody><tr><td>dictCreate</td><td>创建一个空字典</td><td>O(1)</td></tr><tr><td>dictAdd</td><td>添加指定的kv到字典中</td><td>O(1)</td></tr><tr><td>dictReplace</td><td>添加指定的kv到字典中，如果已经存在，则替换</td><td>O(1)</td></tr><tr><td>dictFetchValue</td><td>返回给定键的值</td><td>O(1)</td></tr><tr><td>dictGetRandomKey</td><td>返回随机的kv</td><td>O(1)</td></tr><tr><td>dictDelete</td><td>删除给定键对应的键值对</td><td>O(1)</td></tr><tr><td>dictRelease</td><td>释放给定字典</td><td>O(n)</td></tr></tbody></table><h3 id="字典总结"><a href="#字典总结" class="headerlink" title="字典总结"></a>字典总结</h3><blockquote><p>字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。</p><p>Redis中的字典使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。</p><p>当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。</p><p>哈希表使用链地址法来解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</p><p>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对rehash到新哈希表里面，并且这个rehash过程并不是一次性地完成的，而是渐进式地完成的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现（2-链表）</title>
      <link href="/RoyalLiang.github.io/post/717cfc9a.html"/>
      <url>/RoyalLiang.github.io/post/717cfc9a.html</url>
      
        <content type="html"><![CDATA[<p>链表是Redis底层用非常广泛的数据结构。使用范围包含但不限于：列表键，发布与订阅、慢查询、监视器、客户端状态信息等</p><h3 id="链表节点实现"><a href="#链表节点实现" class="headerlink" title="链表节点实现"></a>链表节点实现</h3><p>每个链表节点使用一个adlist.h&#x2F;listNode结构来表示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct listNode&#123;</span><br><span class="line">    //前置节点</span><br><span class="line">    struct listNode * prev;</span><br><span class="line">    //后置节点</span><br><span class="line">    struct listNode * next;</span><br><span class="line">    //节点值</span><br><span class="line">    void * value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>使用多个listNode结构就可以组成链表，但使用adlist.h&#x2F;list来持有链表的话，操作起来会更方便：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct list&#123;</span><br><span class="line">    //头节点</span><br><span class="line">    listNode * head;</span><br><span class="line">    //尾节点</span><br><span class="line">    listNode * tail;</span><br><span class="line">    //链表节点数量</span><br><span class="line">    unsigned long len;</span><br><span class="line">    //节点值复制函数</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    //节点值释放函数</span><br><span class="line">    void *(*free)(void *ptr);</span><br><span class="line">    //节点值比较函数</span><br><span class="line">    void *(*match)(void *ptr, void *key);</span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure><blockquote><p>list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数：</p></blockquote><ol><li>dup函数用于复制链表节点所保存的值；</li><li>free函数用于释放链表节点所保存的值；</li><li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li></ol><p>Redis链表特征：</p><ol><li>双端，每个节点都带有prev节点和next节点。</li><li>无环，表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点。</li><li>带表头指针和表尾指针。</li><li>带链表长度计数器，程序使用list结构的len属性来对list持有的链表节点进行计数。</li><li>多态，链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。</li></ol><h3 id="链表-API"><a href="#链表-API" class="headerlink" title="链表 API"></a>链表 API</h3><table><thead><tr><th>函数</th><th>作用</th><th>时间复杂度</th></tr></thead><tbody><tr><td>listSetDupMethod</td><td>将给定的函数设置成链表节点值复制函数</td><td>O(1)，通过链表的dup属性直接获得</td></tr><tr><td>listGetDupMethod</td><td>返回链表当前正在使用的节点值复制函数</td><td>O(1)</td></tr><tr><td>listSetFreeMethod</td><td>将给定的函数设置成链表节点值释放函数</td><td>O(1)</td></tr><tr><td>listGetFree</td><td>返回链表当前节点值释放函数</td><td>O(1)</td></tr><tr><td>listSetMatchMethod</td><td>将给定的函数设置成链表节点值对比函数</td><td>O(1)</td></tr><tr><td>listGetMatchMethod</td><td>返回链表当前节点值对比函数</td><td>O(1)</td></tr><tr><td>listLength</td><td>返回链表长度</td><td>O(1)</td></tr><tr><td>listFirst</td><td>返回链表头节点</td><td>O(1)</td></tr><tr><td>listLast</td><td>返回链表尾节点</td><td>O(1)</td></tr><tr><td>listPrevNode</td><td>返回给定节点的前置节点</td><td>O(1)</td></tr><tr><td>listNextNode</td><td>返回给定节点的后置节点</td><td>O(1)</td></tr><tr><td>listNodeValue</td><td>返回给定节点当前值</td><td>O(1)</td></tr><tr><td>listCreate</td><td>创建不包含任何值的空链表</td><td>O(1)</td></tr><tr><td>listAddNodeHead</td><td>将给定值的新节点添加到表头</td><td>O(1)</td></tr><tr><td>listAddNodeTail</td><td>将给定值的新节点添加到表尾</td><td>O(1)</td></tr><tr><td>listInsertNode</td><td>将给定值的新节点插入到链表指定位置</td><td>O(1)</td></tr><tr><td>listSearchKey</td><td>查找并返回链表中给定值的节点</td><td>O(n)</td></tr><tr><td>listIndex</td><td>返回链表给定索引的节点</td><td>O(n)</td></tr><tr><td>listDelNode</td><td>删除链表给定节点</td><td>O(n)</td></tr><tr><td>listRotate</td><td>将表尾节点弹出并设置成新的表头节点</td><td>O(1)</td></tr><tr><td>listDup</td><td>添加给定链表副本</td><td>O(n)</td></tr><tr><td>listRelease</td><td>释放给定链表</td><td>O(n)</td></tr></tbody></table><h3 id="链表总结"><a href="#链表总结" class="headerlink" title="链表总结"></a>链表总结</h3><ol><li>链表被广泛用于实现Redis的各种功能，比如列表键、发布与订阅、慢查询、监视器等。</li><li>每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。</li><li>每个链表使用一个list结构来表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。</li><li>因为链表表头节点的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。</li><li>通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis设计与实现（1-字符串）</title>
      <link href="/RoyalLiang.github.io/post/8c0492ea.html"/>
      <url>/RoyalLiang.github.io/post/8c0492ea.html</url>
      
        <content type="html"><![CDATA[<p>每个sds.h&#x2F;sdshdr结构表示一个SDS值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    //记录buf数组重已使用字节的数量，等于SDS所保存字符串的长度</span><br><span class="line">    int len;</span><br><span class="line">    //记录buf数组中未使用字节的数量</span><br><span class="line">    int free;</span><br><span class="line">    //字节数组，用来保存字符串</span><br><span class="line">    char buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>free属性的值为0，表示这个SDS没有分配任何未使用空间。</p><p>len属性的值为5，表示这个SDS保存了一个五字节长的字符串。</p><p>buf属性是一个char类型的数组，最后一个字节保存空字符’\0’。</p><p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。</p></blockquote><p>示例：</p><p><img src="https://cdn.notfound.icu/hexo/sds.png"></p><p><strong>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面。</strong></p><p><strong>通过 len 属性，</strong><code>SDS</code> 获取字符串长度时，其时间复杂度为 O(1) 。</p><p><strong>通过检查SDS的空间是否满足修改所需的要求，杜绝了缓冲区溢出的可能性。</strong></p><p>当 SDS API 需要对<code>SDS</code>进行修改时，API 会先检查<code>SDS</code>的空间是否满足修改所需的要求，如果不满足的话，API 会自动将<code>SDS</code>的空间扩展至执行修改所需的大小，然后才执行实际的修改操作。</p><p><strong>通过未使用空间解除了字符串长度和底层数组长度之间的关联，减少了内存重分配的次数。</strong></p><p>在<code>SDS</code>中，buf 数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由<code>SDS</code>的 free 属性记录。</p><p><strong>通过未使用空间，</strong><strong><code>SDS</code>实现了空间预分配和惰性空间释放两种优化策略。</strong></p><p>空间预分配用于优化<code>SDS</code>的字符串增长操作：当<code>SDS</code>的 API 对一个SDS进行修改，并且需要对<code>SDS</code>进行空间扩展的时候，程序不仅会为<code>SDS</code>分配修改所必要的空间，还会为<code>SDS</code>分配额外的未使用空间。</p><p>惰性空间释放用于优化<code>SDS</code>的字符串缩短操作：当<code>SDS</code>的 API 需要缩短<code>SDS</code>保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用。</p><p><strong><code>SDS</code> 是二进制安全的。</strong></p><p>所有 SDS API 都会以处理二进制的方式来处理<code>SDS</code>存放在 buf 数组里的数据。</p><h3 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h3><p><img src="https://cdn.notfound.icu/hexo/sdsapi.png"></p>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 安装Redis6.0</title>
      <link href="/RoyalLiang.github.io/post/12a6d824.html"/>
      <url>/RoyalLiang.github.io/post/12a6d824.html</url>
      
        <content type="html"><![CDATA[<p>今天给一台崭新的服务器(CentOS 7.7)安装Redis时才发现，Redis已经更新到了6.0(手动滑稽)，抱着用心不用旧的心态，立马喜滋滋地下载，上传到服务器上面开始安装，结果刚开始就碰壁了。再次记录一下安装的小坑。本文不讨论Redis6.0的新特性，仅记录安装踩到的坑。</p><h1 id="下载Redis6-0"><a href="#下载Redis6-0" class="headerlink" title="下载Redis6.0"></a>下载Redis6.0</h1><ol><li><p>使用linux wget命令：</p><blockquote><p>wget <a href="http://download.redis.io/releases/redis-6.0.1.tar.gz">http://download.redis.io/releases/redis-6.0.1.tar.gz</a></p></blockquote></li><li><p>前往官网下载，使用文件传输工具传输至服务器。</p></li></ol><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><p>安装Redis需要安装依赖，命令如下：</p><blockquote><p>yum install gcc gcc-c++ -y</p></blockquote><p>需要注意的是，Redis6.0需要gcc版本不能过低，最好5.0版本以上，否则会编译出错。</p><p>升级系统gcc命令如下：</p><ol><li>安装centos-release-scl。</li></ol><blockquote><p>yum install centos-release-scl</p></blockquote><ol start="2"><li>安装devtoolset，注意，如果想安装7.<em>版本的，就改成devtoolset-7-gcc</em>。</li></ol><blockquote><p>yum install devtoolset-8-gcc*</p></blockquote><ol start="3"><li>激活对应的devtoolset，所以你可以一次安装多个版本的devtoolset，需要的时候用下面这条命令切换到对应的版本。</li></ol><blockquote><p>scl enable devtoolset-8 bash</p></blockquote><h1 id="编译、安装"><a href="#编译、安装" class="headerlink" title="编译、安装"></a>编译、安装</h1><p>解压安装包</p><blockquote><p>tar -zxvf 压缩包.tar.gz</p></blockquote><p>进入解压文件夹</p><blockquote><p>cd Redis安装包文件夹</p></blockquote><p>编译、安装</p><blockquote><p>make</p><p>make install </p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译</span><br><span class="line">make</span><br><span class="line"># 安装</span><br><span class="line">make install PREFIX=/usr/local/redis# PREFIX后的路径可以修改成自己想改的</span><br></pre></td></tr></table></figure><h1 id="添加软链接"><a href="#添加软链接" class="headerlink" title="添加软链接"></a>添加软链接</h1><p>安装完成后，会发现redis-server，redis-cli命令不可用。不用着急。添加两个软连接就可以了，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加redis-server软连接</span><br><span class="line">ln -s /usr/local/redis/bin/redis-server /usr/bin/redis-server</span><br><span class="line">添加redis-cli软连接</span><br><span class="line">ln -s /usr/local/redis/bin/redis-scli /usr/bin/redis-cli</span><br></pre></td></tr></table></figure><p>以上就是全文安装教程，特此记录，网上破烂教程太多，坑的我不要不要的。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记 (1)</title>
      <link href="/RoyalLiang.github.io/post/3c5692e6.html"/>
      <url>/RoyalLiang.github.io/post/3c5692e6.html</url>
      
        <content type="html"><![CDATA[<p>第一次接触Redis，已经记不清是什么时候了，那时候对它的唯一印象就是它是数据库，还能做缓存。对于它的底层，数据结构什么的一概不知，更不用说什么缓存，消息通知什么的了。前段时间又系统的看了一遍Redis视频教程和书本教程，在此做个记录。毕竟好记性不如烂笔头。此为开篇。</p><h1 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h1><p>Redis是基于key-value的存储服务系统，支持多种数据结构，并且是开源的。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li><p>速度快</p><p>Redis速度之所以快的最根本原因，是因为其数据存在内存中。</p></li><li><p>持久化</p><p>以异步的方式将数据保存在硬盘上</p><ul><li>RDB</li><li>AOF</li></ul></li><li><p>多种数据格式</p><ul><li><p>字符串</p></li><li><p>list</p></li><li><p>哈希</p></li><li><p>集合</p></li><li><p>有序集合</p></li><li><p>Bitmaps：位图</p></li><li><p>HyperLogLog：超小内存唯一值计数</p></li><li><p>GEO：地理信息定位</p></li></ul></li><li><p>多功能</p><ul><li>发布订阅</li><li>事务</li><li>Lua脚本</li><li>pipeline</li></ul></li></ol><h2 id="安装-x2F-启动"><a href="#安装-x2F-启动" class="headerlink" title="安装&#x2F;启动"></a>安装&#x2F;启动</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Linux</span><br><span class="line"># 获取安装包</span><br><span class="line">wget 安装包链接</span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf 安装包</span><br><span class="line"># 添加软连接</span><br><span class="line">ln -s 安装包 redis</span><br><span class="line"># 安装</span><br><span class="line">cd redis</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>Redis目录可执行文件说明：</p><ul><li>redis-server: Redis服务器</li><li>redis-cli: Redis命令行客户端</li><li>redis-benchmark：Redis性能测试工具</li><li>redis-check-aof：AOF文件修复工具</li><li>redis-check-dump：RDB文件修复工具</li><li>redis-sentinel：Sentinel服务器</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>最简启动</p><blockquote><p>redis-server</p></blockquote><p>动态参数启动</p><blockquote><p>redis-server –port xxx –host xxx.xxx.xxx.xxx –a password</p></blockquote><p>配置文件启动</p><blockquote><p>redis-server &#x2F;xxx&#x2F;xxx&#x2F;conf&#x2F;redis-xxx.conf</p></blockquote><h2 id="常用-最简-配置"><a href="#常用-最简-配置" class="headerlink" title="常用(最简)配置"></a>常用(最简)配置</h2><ul><li>daemonize：是否守护进程(no | yes)</li><li>port：对外端口号</li><li>logfile： 系统日志文件</li><li>dir：工作目录</li></ul>]]></content>
      
      
      <categories>
          
          <category> 山不厌高 </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Supervisor使用教程</title>
      <link href="/RoyalLiang.github.io/post/c8593bbd.html"/>
      <url>/RoyalLiang.github.io/post/c8593bbd.html</url>
      
        <content type="html"><![CDATA[<h1 id="supervisor简介"><a href="#supervisor简介" class="headerlink" title="supervisor简介"></a>supervisor简介</h1><blockquote><p>Supervisor is a client&#x2F;server system that allows its users to monitor and control a number of processes on UNIX-like operating systems.</p><p>It shares some of the same goals of programs like launchd, daemontools, and runit. Unlike some of these programs, it is not meant to be run as a substitute for <code>init</code> as “process id 1”. Instead it is meant to be used to control processes related to a project or a customer, and is meant to start like any other program at boot time.</p><p>官方文档：<a href="%5B*%E6%96%87%E6%A1%A3%E5%9C%A8%E6%AD%A4*%5D(http://supervisord.org/)">点击此处</a></p></blockquote><p>以上摘自官网，简单来说，supervisor是一个基于Python开发的通用的进程管理程序，是Linux&#x2F;Unix系统上的进程监控工具，可以管理和监控Linux上面的进程，能将一个普通的命令行进程变为后台daemon，并监控进程状态。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>直接使用pip安装</p><blockquote><p>pip install supervisor</p></blockquote></li><li><p>使用easy_install</p><blockquote><p>yum&#x2F;apt-get install python-setuptools</p><p>easy_install supervisor</p></blockquote></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装完成后首先设置配置文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echo_supervisord_conf &gt; 目标文件夹/supervisod.conf</span><br></pre></td></tr></table></figure><p>设置配置文件（最简配置）</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[inet_http_server] </span><br><span class="line">port=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span>;<span class="comment"># 开启web server，外网访问请设置成0.0.0.0 </span></span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ; </span><br><span class="line">serverurl=http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span> ;</span><br><span class="line"> </span><br><span class="line">[include]</span><br><span class="line">files = *.ini<span class="comment"># 包含当前目录下的所有.ini的配置文件</span></span><br></pre></td></tr></table></figure><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>supervisor包含命令行与网页模式。</p><p>supervisorctl：命令行工具，提供一个类似shell的操作接口，通过它你可以连接到不同的supervisord进程上来管理它们各自的子程序，命令通过UNIX socket或者TCP来和服务通讯。</p><p>相关命令：</p><blockquote><p>status：查看当前所有托管程序列表</p><p>update： 更新所有&#x2F;选择程序状态</p><p>reload：重启supervisor</p><p>start 【program_name】：启动某个进程</p><p>restart 【program_name】：重启某个进程</p><p>stop 【program_name】：停止【program_name】进程</p><p>stop groupworker：重启所有属于名为groupworker这个分组的进程(start,restart同理)</p><p>stop all：停止全部进程，注：start、restart、stop都不会载入最新的配置文</p><p>reread：当一个服务由自动启动修改为手动启动时执行一下就ok</p></blockquote><p>Web Server：通过web控制进程。</p><blockquote><p>PS：需要设置[inet_http_server]配置项</p></blockquote><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><blockquote><p>supervisord -c supervisor配置文件夹&#x2F;supervisord.conf</p></blockquote><h1 id="托管程序配置文件示例"><a href="#托管程序配置文件示例" class="headerlink" title="托管程序配置文件示例"></a>托管程序配置文件示例</h1><blockquote><p>test.ini</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[program:显示名称]</span><br><span class="line">command=x x x;需要执行的命令，可携带路径</span><br><span class="line">directory=XXX/XXX       ; 工作路径</span><br><span class="line">priority=999                  ; 优先级，默认999</span><br><span class="line">startsecs = 5        ; 启动 5 秒后没有异常退出，则认为正常启动</span><br><span class="line">autorestart = true   ; 程序异常退出后自动重启</span><br><span class="line">startretries = 3     ; 启动失败自动重试次数，默认3</span><br><span class="line">enviroment=PATH=&quot;使用环境&quot;;例如：/xxx/xxx/虚拟环境/bin/</span><br><span class="line">stdout_logfile = /xxx/logs/scheduler.log;输出日志</span><br><span class="line">stderr_logfile = /xxx/logs/scheduler_err.log;错误输出日志</span><br><span class="line">#把stderr重定向到stdout，默认 false</span><br><span class="line">redirect_stderr = false</span><br><span class="line"># 防止出现僵尸进程</span><br><span class="line">stopasgroup=true</span><br><span class="line">killasgroup=true</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>配置参数介绍</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ;UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ;socket文件的mode，默认是0700</span><br><span class="line">;chown=nobody:nogroup       ;socket文件的owner，格式：uid:gid</span><br><span class="line"> </span><br><span class="line">;[inet_http_server]         ;HTTP服务器，提供web管理界面</span><br><span class="line">;port=127.0.0.1:9001        ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username=user              ;登录管理后台的用户名</span><br><span class="line">;password=123               ;登录管理后台的密码</span><br><span class="line"> </span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小</span><br><span class="line">logfile_backups=10           ;日志文件保留备份数量默认10，设为0表示不备份</span><br><span class="line">loglevel=info                ;日志级别，默认info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ;pid 文件</span><br><span class="line">nodaemon=false               ;是否在前台启动，默认是false，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ;可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs=200                 ;可以打开的进程数的最小值，默认 200</span><br><span class="line"> </span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致</span><br><span class="line">;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord</span><br><span class="line"> </span><br><span class="line">; [program:xx]是被管理的进程配置参数，xx是进程的名称</span><br><span class="line">[program:xx]</span><br><span class="line">command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run  ; 程序启动命令</span><br><span class="line">autostart=true       ; 在supervisord启动的时候也自动启动</span><br><span class="line">startsecs=10         ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒</span><br><span class="line">autorestart=true     ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启</span><br><span class="line">startretries=3       ; 启动失败自动重试次数，默认是3</span><br><span class="line">user=tomcat          ; 用哪个用户启动进程，默认是root</span><br><span class="line">priority=999         ; 进程启动优先级，默认999，值小的优先启动</span><br><span class="line">redirect_stderr=true ; 把stderr重定向到stdout，默认false</span><br><span class="line">stdout_logfile_maxbytes=20MB  ; stdout 日志文件大小，默认50MB</span><br><span class="line">stdout_logfile_backups = 20   ; stdout 日志文件备份数，默认是10</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.out</span><br><span class="line">stopasgroup=false     ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程</span><br><span class="line">killasgroup=false     ;默认为false，向进程组发送kill信号，包括子进程</span><br><span class="line"> </span><br><span class="line">;包含其它配置文件</span><br><span class="line">[include]</span><br><span class="line">files = relative/directory/*.ini    ;可以指定一个或多个以.ini结束的配置文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重拾Hexo主题博客</title>
      <link href="/RoyalLiang.github.io/post/ac2cac82.html"/>
      <url>/RoyalLiang.github.io/post/ac2cac82.html</url>
      
        <content type="html"><![CDATA[<p>去年6月份，接触到了hexo静态博客，一时兴起之下，就跟着教程搭了一个。但只是搭了一个，之后就再也没用过了。一个月之前我便在思考重试起我的博客网站，但依然没想好是使用前后端分离，还是直接使用模板语言，亦或是hexo。一个月后，终于决定还是使用hexo搭建，一时多熟悉一下hexo，第二也是最重要的一点是，想要借助静态博客，锻炼一下我的markdown写作能力，好了，正文开始，此篇为记录下搭建过程。<br><strong>本文不介绍详细安装过程</strong></p><h1 id="工具-x2F-环境搭建"><a href="#工具-x2F-环境搭建" class="headerlink" title="工具&#x2F;环境搭建"></a>工具&#x2F;环境搭建</h1><h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>由于hexo基于nodejs，所以在使用hexo之前需要安装nodejs，安装nodejs方法这里不再赘述，各位看官直接网搜教程即可<br><strong>PS:尽量安装最新&#x2F;稳定版本的nodejs</strong></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>安装好node之后，就可以安装hexo了。打开Terminal，输入npm i hexo-cli -g，等待安装结束后，hexo便安装好了。<br><strong>如果嫌弃安装速度过慢的话，可以配置一下npm的国内下载源，这里不再赘述，直接搜淘宝npm</strong></p><h2 id="使用github"><a href="#使用github" class="headerlink" title="使用github"></a>使用github</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>没有过github经历的朋友，先去网上搜一下github(国内访问可能会慢)，跟着网站指引，注册一个账号后在本级下载git工具。下载地址:<a href="https://git-scm.com/downloads">官网下载</a></p><h3 id="设置git"><a href="#设置git" class="headerlink" title="设置git"></a>设置git</h3><p>下载之后设置邮箱、用户名、ssh-key，将public-key添加到git我的ssh—key中即可，这里不再赘述，命令如下：<br><code>git config --global user.name &quot;你的git用户名&quot; git config --global user.email &quot;用来注册git的邮箱号码&quot; 生成密钥SSH key： ssh-keygen -t rsa -C &quot;用来注册git的邮箱号码&quot; 生成的ssh-key路径在C://users/电脑用户名/.ssh/下的rsa_pub(Windows)，Mac/Linux的路径为~/.ssh/id_rsa.pub </code></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>上述操作做好之后，将你的公钥配置在git中即可。<br>之后新建仓库，名称随意，但在名字后必须加上.github.io。且仓库需要是公共仓库。</p><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><p>创建仓库之后，点击仓库右上角的setting按钮，页面下拉，找到github page，点击choose themes即可开始使用github静态博客。</p><h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><p>添加一个博客目录，例如c:&#x2F;&#x2F;projects&#x2F;hexoproject<br>在该路径打开Terminal，执行如下命令：<br>初始化hexo博客<br><code>hexo init hexo g</code><br>启动服务<br><code>hexo s</code><br>上传到git(需要先配置config文件)<br><code>hexo d</code></p><h3 id="设置博客配置git"><a href="#设置博客配置git" class="headerlink" title="设置博客配置git"></a>设置博客配置git</h3><p>打开博客根目录下的<code>_config.yml</code>文件，找到最后修改为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/用户名/项目名.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>配置完成后即可使用<code>hexo d</code>命令。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p><strong>购买域名，实名认证、域名备案为前提。</strong><br>解决完上述问题之后，打开域名控制台，设置域名解析，添加两个<code>CNAME</code>解析，主机记录分别为<code>www</code>和<code>@</code>，记录值都是项目名称<code>xxx.github.io</code><br>完成后，在<code>git</code>项目页面点击<code>setting</code>，下拉找到<code>custom domain</code>，将其值设置为你的域名，点击保存即可。</p><p>以上即为本文的全部内容，只是记录了搭建博客的基本流程，进阶设置后期再说。各位看官，咱们下期再见～</p><p><img src="https://cdn.notfound.icu/hexo/SC04C06.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
